<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>C++关键字之explicit</title>
    <url>/2022/12/06/C++%E5%85%B3%E9%94%AE%E5%AD%97%E4%B9%8Bexplicit/</url>
    <content><![CDATA[<p>在C++中 <code>explicit</code>关键字只能用来修饰单参构造函数。</p>
<p>与之对应的关键字为 <code>implicit</code>，其含义为“隐式的”，类的构造函数默认声明为 <code>implicit</code>。</p>
<h2 id="1-隐式声明的构造函数"><a href="#1-隐式声明的构造函数" class="headerlink" title="1. 隐式声明的构造函数"></a>1. 隐式声明的构造函数</h2><div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">CxString</span></span><br><span class="line">&#123;  </span><br><span class="line"><span class="keyword">public</span>:  </span><br><span class="line">    <span class="type">char</span> *_pstr;  </span><br><span class="line">    <span class="type">int</span> _size;  </span><br><span class="line">    <span class="built_in">CxString</span>(<span class="type">int</span> size)  </span><br><span class="line">    &#123;  </span><br><span class="line">        _size = size;                       <span class="comment">// string的预设大小  </span></span><br><span class="line">        _pstr = (<span class="type">char</span>*)<span class="built_in">malloc</span>(size + <span class="number">1</span>);    <span class="comment">// 分配string的内存  </span></span><br><span class="line">        <span class="built_in">memset</span>(_pstr, <span class="number">0</span>, size + <span class="number">1</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="built_in">CxString</span>(<span class="type">const</span> <span class="type">char</span> *p)  </span><br><span class="line">    &#123;  </span><br><span class="line">        <span class="type">int</span> size = <span class="built_in">strlen</span>(p);  </span><br><span class="line">        _pstr = (<span class="type">char</span>*)<span class="built_in">malloc</span>(size + <span class="number">1</span>);    <span class="comment">// 分配string的内存  </span></span><br><span class="line">        <span class="built_in">strcpy</span>(_pstr, p);            <span class="comment">// 复制字符串  </span></span><br><span class="line">        _size = <span class="built_in">strlen</span>(_pstr);  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="comment">// 析构函数这里不讨论, 省略...  </span></span><br><span class="line">&#125;;  </span><br><span class="line"></span><br><span class="line">    <span class="function">CxString <span class="title">string1</span><span class="params">(<span class="number">1</span>)</span></span>;      <span class="comment">// 正确，调用 CxString(int size) </span></span><br><span class="line">    CxString string2 = <span class="number">2</span>;     <span class="comment">// 正确，调用 CxString(int size)   </span></span><br><span class="line">    CxString string3;         <span class="comment">// 错误，无默认的构造函数</span></span><br><span class="line">    <span class="function">CxString <span class="title">string4</span><span class="params">(<span class="string">&quot;123&quot;</span>)</span></span>;  <span class="comment">// 正确，调用 CxString(const char *p) </span></span><br><span class="line">    CxString string5 = <span class="string">&quot;456&quot;</span>; <span class="comment">// 正确，调用 CxString(const char *p) </span></span><br><span class="line">    CxString string6 = <span class="string">&#x27;a&#x27;</span>;   <span class="comment">// 正确，但是调用 CxString(int size)，size的值为&#x27;a&#x27;的ascii码</span></span><br></pre></td></tr></table></figure></div>

<p>在C++中，如果构造函数只有一个参数时，在编译的时候就会有一个缺省的类型转换操作，也就是将对应的数据类型转换为该类对象。所以说：</p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line">CxString string2 = <span class="number">2</span>;</span><br></pre></td></tr></table></figure></div>

<p>实际上等同于：</p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">CxString <span class="title">string2</span><span class="params">(<span class="number">2</span>)</span></span>;</span><br><span class="line"><span class="comment">// 或以下形式</span></span><br><span class="line"><span class="function">CxString <span class="title">tmp</span><span class="params">(<span class="number">2</span>)</span></span>;</span><br><span class="line">CxString string2 = tmp;   </span><br></pre></td></tr></table></figure></div>

<p>关于<code>string6</code>的情况类似，只不过将<code>&#39;a&#39;</code>转化成了对应的ascii码。<br>但是以上两种写法并不具有很好的可读性，为了避免这种情况产生，可以使用<code>explicit</code>关键字阻止隐式的自动类型转换。</p>
<h2 id="2-显式声明的构造函数"><a href="#2-显式声明的构造函数" class="headerlink" title="2.显式声明的构造函数"></a>2.显式声明的构造函数</h2><p>使用<code>explicit</code>关键字可以阻止类构造函数的隐式类型转换。</p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">CxString</span></span><br><span class="line">&#123;  </span><br><span class="line"><span class="keyword">public</span>:  </span><br><span class="line">    <span class="type">char</span> *_pstr;  </span><br><span class="line">    <span class="type">int</span> _size;  </span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">CxString</span><span class="params">(<span class="type">int</span> size)</span>  </span></span><br><span class="line"><span class="function">    </span>&#123;  </span><br><span class="line">        _size = size;                       <span class="comment">// string的预设大小  </span></span><br><span class="line">        _pstr = (<span class="type">char</span>*)<span class="built_in">malloc</span>(size + <span class="number">1</span>);    <span class="comment">// 分配string的内存  </span></span><br><span class="line">        <span class="built_in">memset</span>(_pstr, <span class="number">0</span>, size + <span class="number">1</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="built_in">CxString</span>(<span class="type">const</span> <span class="type">char</span> *p)  </span><br><span class="line">    &#123;  </span><br><span class="line">        <span class="type">int</span> size = <span class="built_in">strlen</span>(p);  </span><br><span class="line">        _pstr = (<span class="type">char</span>*)<span class="built_in">malloc</span>(size + <span class="number">1</span>);    <span class="comment">// 分配string的内存  </span></span><br><span class="line">        <span class="built_in">strcpy</span>(_pstr, p);            <span class="comment">// 复制字符串  </span></span><br><span class="line">        _size = <span class="built_in">strlen</span>(_pstr);  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="comment">// 析构函数这里不讨论, 省略...  </span></span><br><span class="line">&#125;;  </span><br><span class="line">    <span class="function">CxString <span class="title">string1</span><span class="params">(<span class="number">1</span>)</span></span>;      <span class="comment">// 正确，调用 CxString(int size) </span></span><br><span class="line">    CxString string2 = <span class="number">2</span>;     <span class="comment">// 错误  </span></span><br><span class="line">    CxString string3;         <span class="comment">// 错误，无默认的构造函数</span></span><br><span class="line">    <span class="function">CxString <span class="title">string4</span><span class="params">(<span class="string">&quot;123&quot;</span>)</span></span>;  <span class="comment">// 正确，调用 CxString(const char *p) </span></span><br><span class="line">    CxString string5 = <span class="string">&quot;456&quot;</span>; <span class="comment">// 正确，调用 CxString(const char *p)</span></span><br><span class="line">    CxString string6 = <span class="string">&#x27;a&#x27;</span>;   <span class="comment">// 正确，但是调用 CxString(int size)，size的值为&#x27;a&#x27;的ascii码</span></span><br></pre></td></tr></table></figure></div>

<h2 id="3-特殊情况：多参构造函数"><a href="#3-特殊情况：多参构造函数" class="headerlink" title="3.特殊情况：多参构造函数"></a>3.特殊情况：多参构造函数</h2><p>文章开头提到<code>explicit</code>关键字只适用于单参构造函数，因为如果类构造函数的参数大于等于两个时，不会触发隐式类型转换，那么<code>explicit</code>关键字随之无效，但是有一种特殊情况，也就是<strong>除了第一个参数以外的其他参数都有默认值的时候，<code>explicit</code>关键字仍然有效</strong>。</p>
<h2 id="4-总结"><a href="#4-总结" class="headerlink" title="4.总结"></a>4.总结</h2><p><code>explicit</code>关键字只用于声明类的单参构造函数（包括上述特殊情况）。<br>《Effective C++》提到：被声明为<code>explicit</code>的构造函数通常比其<code>non-explicit</code>兄弟更受欢迎。因为它们禁止编译器执行非预期（往往也不被期望）的类型转换。</p>
]]></content>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>C++关键字之constexpr</title>
    <url>/2022/12/06/C++%E5%85%B3%E9%94%AE%E5%AD%97%E4%B9%8Bconstexpr/</url>
    <content><![CDATA[<p><code>constexpr</code>关键字的功能是使指定的常量表达式获得在程序编译阶段计算出结果的能力，而不必等到程序运行阶段。C++ 11 标准中，<code>constexpr</code>可用于修饰普通变量、函数（包括模板函数）以及类的构造函数。</p>
<h2 id="1-constexpr修饰普通变量"><a href="#1-constexpr修饰普通变量" class="headerlink" title="1.constexpr修饰普通变量"></a>1.<code>constexpr</code>修饰普通变量</h2><p>C++11 标准中，定义变量时可以用<code>constexpr</code>修饰，从而使该变量获得在编译阶段即可计算出结果的能力。<br>需要注意的是：使用 constexpr 修饰普通变量时，变量必须经过初始化且初始值必须是一个常量表达式。举个例子：</p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">constexpr</span> <span class="type">int</span> num = <span class="number">1</span> + <span class="number">2</span> + <span class="number">3</span>;</span><br><span class="line">    <span class="type">int</span> url[num] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>&#125;;</span><br><span class="line">    cout&lt;&lt; url[<span class="number">1</span>] &lt;&lt; endl;    <span class="comment">//2</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h2 id="2-constexpr修饰函数"><a href="#2-constexpr修饰函数" class="headerlink" title="2.constexpr修饰函数"></a>2.<code>constexpr</code>修饰函数</h2><p><code>constexpr</code>还可以用于修饰函数的返回值，这样的函数又称为<strong>常量表达式函数</strong>。<br>但是<code>constexpr</code>并不能修饰任意函数的返回值，对于函数有以下几个要求：</p>
<p>一、<strong>整个函数的函数体中，除了可以包含<code>using</code>指令、<code>typedef</code>语句以及<code>static_assert</code>断言外，只能包含一条 <code>return</code>返回语句。</strong><br>对于C++11来说要求如上，但在C++14中解除了对<code>constexpr</code>函数的大部分限制。详情可以查阅相关文档。</p>
  <div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">constexpr</span> <span class="type">int</span> <span class="title">func</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> ret = <span class="number">1</span> + <span class="number">2</span> + x;</span><br><span class="line">  <span class="keyword">return</span> ret;</span><br><span class="line">&#125;<span class="comment">//错误写法</span></span><br><span class="line"><span class="function"><span class="keyword">constexpr</span> <span class="type">int</span> <span class="title">func</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">  <span class="comment">//可以添加 using 执行、typedef 语句以及 static_assert 断言</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">1</span> + <span class="number">2</span> + x;</span><br><span class="line">&#125;<span class="comment">//正确写法</span></span><br></pre></td></tr></table></figure></div>

<p>二、<strong>该函数必须有返回值，并且类型不能是<code>void</code></strong></p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">constexpr</span> <span class="type">void</span> <span class="title">func</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//函数体</span></span><br><span class="line">&#125;<span class="comment">//错误，通过此函数无法获得一个常量</span></span><br></pre></td></tr></table></figure></div>

<p>三、<strong>函数在使用之前，必须有对应的定义语句。</strong><br>对于其他的函数来说，在使用时前给出声明即可，并不需要在给出定义。但是对于常量表达式函数来说，由于其返回值会在编译过程中进行计算，所以使用之前一定需要知道函数具体的定义。</p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">//普通函数的声明</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">noconst_func</span><span class="params">(<span class="type">int</span> x)</span></span>;</span><br><span class="line"><span class="comment">//常量表达式函数的声明</span></span><br><span class="line"><span class="function"><span class="keyword">constexpr</span> <span class="type">int</span> <span class="title">func</span><span class="params">(<span class="type">int</span> x)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//常量表达式函数的定义</span></span><br><span class="line"><span class="function"><span class="keyword">constexpr</span> <span class="type">int</span> <span class="title">func</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span> + <span class="number">2</span> + x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//调用常量表达式函数</span></span><br><span class="line">    <span class="type">int</span> a[<span class="built_in">func</span>(<span class="number">3</span>)] = &#123; <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span> &#125;;</span><br><span class="line">    cout &lt;&lt; a[<span class="number">2</span>] &lt;&lt; endl;</span><br><span class="line">    <span class="comment">//调用普通函数</span></span><br><span class="line">    cout &lt;&lt; <span class="built_in">noconst_func</span>(<span class="number">3</span>) &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//普通函数的定义</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">noconst_func</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span> + <span class="number">2</span> + x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>四、<strong>返回的表达式必须是常量表达式</strong></p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> num = <span class="number">3</span>;</span><br><span class="line"><span class="function"><span class="keyword">constexpr</span> <span class="type">int</span> <span class="title">func</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> num + x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//调用常量表达式函数</span></span><br><span class="line">    <span class="type">int</span> a[<span class="built_in">func</span>(<span class="number">3</span>)] = &#123; <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span> &#125;;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;<span class="comment">//error:func(3) 的结果不是常量</span></span><br></pre></td></tr></table></figure></div>

<p>常量表达式函数的返回值必须是常量表达式的原因很简单，如果想在程序编译阶段获得某个函数返回的常量，则该函数的<code>return</code>语句中就不能包含程序运行阶段才能确定值的变量(上述代码中的<code>num</code>)。</p>
<p><strong>注：在常量表达式函数的<code>return</code>语句中，不能包含赋值的操作（例如 <code>return x=1</code> 在常量表达式函数中不允许的）。另外，用 <code>constexpr</code> 修改函数时，函数本身也是支持递归的。</strong></p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">constexpr</span> <span class="type">int</span> <span class="title">fact</span><span class="params">(<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 递归求阶乘</span></span><br><span class="line">    <span class="keyword">return</span> n == <span class="number">1</span> ? <span class="number">1</span> : n * <span class="built_in">fact</span>(n - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h2 id="3-constexpr修饰类的构造函数"><a href="#3-constexpr修饰类的构造函数" class="headerlink" title="3.constexpr修饰类的构造函数"></a>3.<code>constexpr</code>修饰类的构造函数</h2><p>对于 C++ 内置类型的数据，可以直接用<code>constexpr</code>修饰，但如果是自定义的数据类型（结构体或者类），是不可以直接用<code>constexpr</code>修饰的。</p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">//自定义类型的定义</span></span><br><span class="line"><span class="keyword">constexpr</span> <span class="keyword">struct</span> <span class="title class_">myType</span> &#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>* name;</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">    <span class="comment">//其它结构体成员</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">constexpr</span> <span class="keyword">struct</span> <span class="title class_">myType</span> mt &#123; <span class="string">&quot;zhangsan&quot;</span>, <span class="number">10</span> &#125;;</span><br><span class="line">    cout &lt;&lt; mt.name &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; mt.age &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;<span class="comment">//error:constexpr不能修饰自定义类型</span></span><br></pre></td></tr></table></figure></div>

<p>为了自定义一个可以产生常量的类型，可以在该类型的内部添加一个常量构造函数。将上述错误例程修改如下：</p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">//自定义类型的定义</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">myType</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">constexpr</span> <span class="title">myType</span><span class="params">(<span class="type">char</span> *name,<span class="type">int</span> age)</span>:name(name),age(age)&#123;</span>&#125;;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>* name;</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">    <span class="comment">//其它结构体成员</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">constexpr</span> <span class="keyword">struct</span> <span class="title class_">myType</span> mt &#123; <span class="string">&quot;shiszhi&quot;</span>, <span class="number">20</span> &#125;;</span><br><span class="line">    cout &lt;&lt; mt.name &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; mt.age &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;<span class="comment">//output:shiszhi 20</span></span><br></pre></td></tr></table></figure></div>

<p>注意: <strong><code>constexpr</code>修饰类的构造函数时，要求该构造函数的函数体必须为空，且采用初始化列表的方式为各个成员赋值时，必须使用常量表达式。</strong><br>前面提到，<code>constexpr</code>可用于修饰函数，当然也可以修饰类内的成员函数，只要满足上述四个条件即可。不过需要注意的是，<strong>在C++11标准中，不支持用<code>constexpr</code>修饰带有<code>virtual</code>的成员方法。</strong></p>
<h2 id="4-constexpr修饰模板函数"><a href="#4-constexpr修饰模板函数" class="headerlink" title="4.constexpr修饰模板函数"></a>4.<code>constexpr</code>修饰模板函数</h2><p>C++11语法中，<code>constexpr</code>可以修饰模板函数，但由于模板中类型的不确定性，因此模板函数实例化后的函数是否符合常量表达式函数的要求也是不确定的。<br>针对这种情况，C++11标准规定，如果<code>constexpr</code>修饰的模板函数实例化结果不满足常量表达式函数的要求，则<code>constexpr</code>会被自动忽略，即该函数就等同于一个普通函数。</p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">//自定义类型的定义</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">myType</span> &#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>* name;</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">    <span class="comment">//其它结构体成员</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//模板函数</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">constexpr</span> T <span class="title">display</span><span class="params">(T t)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> t;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">myType</span> stu&#123;<span class="string">&quot;shiszhi&quot;</span>, <span class="number">20</span>&#125;;</span><br><span class="line">    <span class="comment">//普通函数,stu未定义常量表达式构造函数</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">myType</span> ret = <span class="built_in">display</span>(stu);</span><br><span class="line">    cout &lt;&lt; ret.name &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; ret.age &lt;&lt; endl;</span><br><span class="line">    <span class="comment">//常量表达式函数</span></span><br><span class="line">    <span class="keyword">constexpr</span> <span class="type">int</span> ret1 = <span class="built_in">display</span>(<span class="number">20</span>);</span><br><span class="line">    cout &lt;&lt; ret1 &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h2 id="5-总结"><a href="#5-总结" class="headerlink" title="5.总结"></a>5.总结</h2><p>《Effective Modern C++》中提到：只要有可能使用<code>constexpr</code>，就使用它。比起非<code>constexpr</code>对象或者<code>constexpr</code>函数而言，<code>constexpr</code>对象或者<code>constexpr</code>函数可以用在一个作用域更广的语境中。</p>
]]></content>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>FFmpeg之FFmpeg简介</title>
    <url>/2022/12/07/FFmpeg%E4%B9%8BFFmpeg%E7%AE%80%E4%BB%8B/</url>
    <content><![CDATA[<h2 id="1-FFmpeg定义"><a href="#1-FFmpeg定义" class="headerlink" title="1. FFmpeg定义"></a>1. FFmpeg定义</h2><p>FFmpeg是一款音视频编解码工具，同时也是一组音视频编解码开发套件，为开发者提供了丰富的音视频处理的调用接口。<br>FFmpeg提供了多种媒体格式的封装和解封装，包括多种音视频解码、多种协议的流媒体、多种色彩格式转换、多种采样率转换、多种码率转换等；FFmpeg框架提供了多种丰富的插件模块，包含封装与解封装的插件、编码与解码的插件等。</p>
<h2 id="2-FFmpeg的基本组成"><a href="#2-FFmpeg的基本组成" class="headerlink" title="2. FFmpeg的基本组成"></a>2. FFmpeg的基本组成</h2><p>FFmpeg框架的基本组成包含<code>AVFormat</code>、<code>AVCodec</code>、<code>AVFilter</code>、<code>AVDevice</code>、<code>AVUtil</code>等模块，结构图如下：<br><img lazyload src="/images/loading.svg" data-src="/2022/12/07/FFmpeg%E4%B9%8BFFmpeg%E7%AE%80%E4%BB%8B/2-1.png" alt="图2-1 FFmpeg基本组成模块"></p>
<ol>
<li><strong>FFmpeg的封装模块AVFormat</strong><br>AVFormat中实现了目前多媒体领域中的绝大多数媒体封装格式，包括封装和解封装，如MP4、FLV、KV、TS等文件封装格式，RTMP、RTSP、MMS、HLS等网络协议封装格式。<br>FFmpeg是否支持某种媒体封装格式，取决于编译时是否包含了该格式的封装库、根据实际需求可以进行媒体封装格式的扩展，增加自己定制的封装格式。</li>
<li><strong>FFmpeg的编解码模块AVCodec</strong><br>AVCodec中实现了目前多媒体领域绝大多数常用的编解码格式，既支持编码，也支持解码。<br>AVCodec除了支持MPEG4、AAC、MJPEG等自带的媒体编解码格式之外，还支持第三方编解码器。<br>如果希望增加自己的编码格式，或者硬件编解码，则需要在AVCodec中增加相应的编解码模块。</li>
<li><strong>FFmpeg的滤镜模块AVFilter</strong><br>AVFilter库提供了一个通用的音频、视频、字幕等滤镜处理框架。在AVFilter中，滤镜框架可以有多个输入和多个输出。可以参考以下示例：<br><img lazyload src="/images/loading.svg" data-src="/2022/12/07/FFmpeg%E4%B9%8BFFmpeg%E7%AE%80%E4%BB%8B/2-2.png" alt="图2-2 AVFilter使用样例"><br>上图中所示的滤镜处理将输入的视频切割成了两部分流，一部分流抛给crop滤镜与vflip滤镜处理模块进行操作，另一部分保持原样，当crop滤镜与vflip滤镜处理操作完成之后，将流合并到原有的overlay图层中，并显示在最上一层，输出新的视频。对应的命令如下：</li>
</ol>
<div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line">ffmpeg -i INPUT -vf &quot;split [main][tmp]; [tmp] crop=iw:ih/2:0:0, vflip [flip]; [main][flip] overlay=0:H/2&quot; OUTPUT</span><br></pre></td></tr></table></figure></div>

<p>下面详细说明一下规则，具体如下：</p>
<ul>
<li>相同的Filter线性链之间用逗号分隔</li>
<li>不同的Filter线性链之间用分号分隔</li>
</ul>
<p>在上述示例中，crop与vflip使用的是同一个滤镜处理的线性链，split滤镜和overlay滤镜使用的是另外一个线性链，一个线性链与另一个线性链汇合时时通过方括号<code>[]</code>括起来的标签进行标识的。<br>4. <strong>FFmpeg的视频图像转换计算模块swscale</strong><br>swscale模块提供高级别的图像转换API，允许其进行图像缩放和像素格式转换。<br>例如：将图像从1080P转换成720P或者480P等的缩放，或者将图像数据从YUV420P转换成YUYV等的转换。<br>5. <strong>FFmpeg的音频转换计算模块swresample</strong><br>swresample模块提供了高级别的音频重采样API。例如它允许操作音频采样、音频通道布局转换与布局调整。</p>
<h2 id="3-FFmpeg的编解码工具ffmpeg"><a href="#3-FFmpeg的编解码工具ffmpeg" class="headerlink" title="3. FFmpeg的编解码工具ffmpeg"></a>3. <strong>FFmpeg的编解码工具ffmpeg</strong></h2><p>一个简单的例子：</p>
<div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line">ffmpeg -i input.mp4 output.avi</span><br></pre></td></tr></table></figure></div>

<p>这条简单的命令通过<code>-i</code>指定输入源，然后进行转码和转封装，将结果输出到<code>output.avi</code>中，这条命令主要进行以下流程：</p>
<ol>
<li>获得输入源<code>input.mp4</code></li>
<li>转码、转封装</li>
<li>输出文件<code>output.avi</code></li>
</ol>
<p>下面这条命令和上面的命令具有类似的作用：</p>
<div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line">ffmpeg -i input.mp4 -f avi output.dat</span><br></pre></td></tr></table></figure></div>

<p>此命令通过<code>-f</code>选项指定输出文件的容器格式，两条命令输出的文件名不同，除此之外完全相同。</p>
<p>ffmpeg的主要工作流程如下：</p>
<ol>
<li>解封装(Demuxing)</li>
<li>解码(Decoding)</li>
<li>编码(Encoding)</li>
<li>封装(Muxing)</li>
</ol>
<p>其中需要经过六个步骤，分别为：</p>
<ol>
<li>读取输入源</li>
<li>进行音视频的解封装</li>
<li>解码每一帧音视频数据</li>
<li>编码每一帧音视频数据</li>
<li>进行音视频的重新封装</li>
<li>输出到目标</li>
</ol>
<p><img lazyload src="/images/loading.svg" data-src="/2022/12/07/FFmpeg%E4%B9%8BFFmpeg%E7%AE%80%E4%BB%8B/3-1.png" alt="图3-1 ffmpeg转码工作流程"><br>在上图所示的工作流程中可以看出：ffmpeg首先读取输入源，然后通过Demuxer进行解封装（通过调用<code>libavformat</code>中的接口实现），然后通过Decoder进行解码（通过调用<code>libavcodec</code>中的接口实现），然后通过Encoder将对应的数据进行编码（通过调用<code>libavcodec</code>中的接口实现），接下来将编码后的音视频数据包通过Muxer进行封装（通过调用<code>libavformat</code>中的接口实现），输出称为输出流。</p>
<h2 id="4-FFmpeg的播放器ffplay"><a href="#4-FFmpeg的播放器ffplay" class="headerlink" title="4. FFmpeg的播放器ffplay"></a>4. FFmpeg的播放器ffplay</h2><p>ffplay为FFmpeg提供的播放器，使用FFmpeg的<code>avformat</code>与<code>avcodec</code>可以播放各种媒体文件或流。如果要使用ffplay，需要系统有各种SDL(Simple DirectMedia Layer)提供基础支撑。<br>ffmpeg提供了音视频显示和播放相关的图像信息、音频的波形信息等。</p>
<h2 id="5-Ffmpeg的多媒体分析器ffprobe"><a href="#5-Ffmpeg的多媒体分析器ffprobe" class="headerlink" title="5. Ffmpeg的多媒体分析器ffprobe"></a>5. Ffmpeg的多媒体分析器ffprobe</h2><p>ffprobe可以从媒体文件或者媒体流中获得想要了解的媒体信息，比如音频的参数、视频的参数、媒体容器的参数信息等。<br>其可以帮助分析某个媒体容器中的音频是什么编码格式、视频是什么编码格式，同时可以得到媒体文件中媒体的总时长、复合码率等信息。除此之外也可以分析媒体文件中每个包的长度、包的类型、帧的信息等。</p>
<h2 id="6-FFmpeg编码支持与定制"><a href="#6-FFmpeg编码支持与定制" class="headerlink" title="6. FFmpeg编码支持与定制"></a>6. FFmpeg编码支持与定制</h2><h3 id="6-1-FFmpeg的编解码器支持"><a href="#6-1-FFmpeg的编解码器支持" class="headerlink" title="6.1. FFmpeg的编解码器支持"></a>6.1. FFmpeg的编解码器支持</h3><p>编码器支持：</p>
<div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line">ffmpeg -encoders</span><br></pre></td></tr></table></figure></div>

<p>解码器支持：</p>
<div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line">ffmpeg -decoders</span><br></pre></td></tr></table></figure></div>

<h3 id="6-2-FFmpeg的封装及解封装支持"><a href="#6-2-FFmpeg的封装及解封装支持" class="headerlink" title="6.2. FFmpeg的封装及解封装支持"></a>6.2. FFmpeg的封装及解封装支持</h3><p>封装支持</p>
<div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line">ffmpeg -muxers</span><br></pre></td></tr></table></figure></div>

<p>解封装支持</p>
<div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line">ffmpeg -demuxers</span><br></pre></td></tr></table></figure></div>

<h3 id="6-3-FFmpeg的通信协议支持"><a href="#6-3-FFmpeg的通信协议支持" class="headerlink" title="6.3. FFmpeg的通信协议支持"></a>6.3. FFmpeg的通信协议支持</h3><div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line">ffmpeg -protocols</span><br></pre></td></tr></table></figure></div>

<h2 id="7-小结"><a href="#7-小结" class="headerlink" title="7.小结"></a>7.小结</h2><p>本文主要介绍了FFmpeg的一些基础知识，重点在整个音视频处理流程以及对流媒体传输协议的支持。</p>
]]></content>
      <tags>
        <tag>FFmpeg</tag>
      </tags>
  </entry>
  <entry>
    <title>WebRTC源码分析之任务队列-TaskQueueBase</title>
    <url>/2022/12/06/WebRTC%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E4%B9%8B%E4%BB%BB%E5%8A%A1%E9%98%9F%E5%88%97-TaskQueueBase/</url>
    <content><![CDATA[<h1 id="1-前言"><a href="#1-前言" class="headerlink" title="1. 前言"></a>1. 前言</h1><p>任务队列 <code>TaskQueue</code>是WebRTC中非常核心的一部分，其主要功能是将任务投递到某一个线程执行。<code>TaskQueue</code>是WebRTC中进程交互很重要的方式。<br>本文主要分析 <code>TaskQueue</code>中最重要的基类 <code>TaskQueueBase</code>。<br><code>TaskQueue</code>机制中涉及的其他类后续会继续补充。<br>WebRTC版本：M84</p>
<h1 id="2-正文"><a href="#2-正文" class="headerlink" title="2. 正文"></a>2. 正文</h1><h2 id="2-0-预说明：线程局部存储"><a href="#2-0-预说明：线程局部存储" class="headerlink" title="2.0. 预说明：线程局部存储"></a>2.0. 预说明：线程局部存储</h2><p>任务队列不可避免地涉及到多线程的知识，此处仅简单介绍一下 <code>TaskQueueBase</code>部分涉及到的相关内容以及函数。</p>
<h3 id="2-0-1-线程局部存储概念"><a href="#2-0-1-线程局部存储概念" class="headerlink" title="2.0.1. 线程局部存储概念"></a>2.0.1. 线程局部存储概念</h3><p>线程局部存储（TLS，Thread Local Storage）是线程私有的全局变量。普通的全局变量是多个线程共享的，一个线程对其修改，所有线程均可见。而线程局部存储是线程私有的，每个线程都有自己的一个副本，某个线程对其所做修改只会修改自己的副本，不会影响到其他线程的副本。</p>
<h3 id="2-0-2-pthread-key-t"><a href="#2-0-2-pthread-key-t" class="headerlink" title="2.0.2. pthread_key_t"></a>2.0.2. <code>pthread_key_t</code></h3><div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line">ABSL_CONST_INIT <span class="type">pthread_key_t</span> g_queue_ptr_tls = <span class="number">0</span>;</span><br></pre></td></tr></table></figure></div>

<p>上述声明中 <code>pthread_key_t</code>为前一小节提到的线程局部存储类型</p>
<h3 id="2-0-3-Tls相关函数说明"><a href="#2-0-3-Tls相关函数说明" class="headerlink" title="2.0.3. Tls相关函数说明"></a>2.0.3. <code>Tls</code>相关函数说明</h3><div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">pthread_key_create</span><span class="params">(<span class="type">pthread_key_t</span> *key, <span class="type">void</span> (*destructor)(<span class="type">void</span>*))</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">pthread_setspecific</span><span class="params">(<span class="type">pthread_key_t</span> key, <span class="type">const</span> <span class="type">void</span> *value)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span>* <span class="title">pthread_getspecific</span><span class="params">(<span class="type">pthread_key_t</span> key)</span></span>;</span><br></pre></td></tr></table></figure></div>

<ul>
<li>调用 <code>pthread_key_create</code>函数可以创建 <code>pthread_key_t</code>变量。该函数需要提供两个参数，第一个参数是需要创建的 <code>pthread_key_t</code>变量，第二个参数是一个释放函数，在线程释放其 <code>Tls</code>的时候被调用。如果函数指针被设置成 <code>nullptr</code>，那么系统将调用默认释放函数。该函数成功创建变量时返回0，其他任何返回值均代表出现异常。</li>
<li>当线程中需要存储值的时候，可以调用 <code>pthread_setspcific</code>函数。该函数需要提供两个参数，第一个参数为前面声明的 <code>pthread_key_t</code>变量，第二个为 <code>void*</code>变量，也就意味着可以存储任何类型的值。</li>
<li>如果需要取出所存储的值，调用 <code>pthread_getspecific</code>函数。该函数的参数为前面提到的 <code>pthread_key_t</code>变量，该函数返回 <code>void *</code>类型的值，如需使用，则要进行强制类型转换。</li>
</ul>
<h3 id="2-0-4-InitializeTls"><a href="#2-0-4-InitializeTls" class="headerlink" title="2.0.4. InitializeTls"></a>2.0.4. <code>InitializeTls</code></h3><div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">InitializeTls</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">RTC_CHECK</span>(<span class="built_in">pthread_key_create</span>(&amp;g_queue_ptr_tls, <span class="literal">nullptr</span>)==<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p><code>RTC_CHECK()</code>为WebRTC中的断言宏，当其内部参数为 <code>false</code>时，抛出异常，直接中止当前进程。</p>
<h3 id="2-0-5-GetQueuePtrTls"><a href="#2-0-5-GetQueuePtrTls" class="headerlink" title="2.0.5. GetQueuePtrTls"></a>2.0.5. <code>GetQueuePtrTls</code></h3><div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">pthread_key_t</span> <span class="title">GetQueuePtrTls</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">pthread_once_t</span> init_once = PTHREAD_ONCE_INIT;</span><br><span class="line">    <span class="built_in">RTC_CHECK</span>(<span class="built_in">pthread_once</span>(&amp;init_once, &amp;InitializeTls) == <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> g_queue_ptr_tls; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>调用 <code>pthread_once()</code>函数，传入初值为 <code>PTHREAD_ONCE_INIT</code>的 <code>init_once</code>变量，结合 <code>RTC_CHECK()</code>断言保证 <code>InitializeTls()</code>函数仅执行一次。</p>
<h3 id="2-0-6-说明"><a href="#2-0-6-说明" class="headerlink" title="2.0.6. 说明"></a>2.0.6. 说明</h3><ul>
<li>上述所有函数为全局函数 不属于任何一个对象</li>
<li>上述所有函数只在 <code>WEBRTC_POSIX</code>宏定义的前提下被定义，否则不被定义</li>
<li>定义这些函数是为了供 <code>TaskQueueBase</code>类使用</li>
</ul>
<h2 id="2-1-QueuedTask类"><a href="#2-1-QueuedTask类" class="headerlink" title="2.1. QueuedTask类"></a>2.1. <code>QueuedTask</code>类</h2><blockquote>
<p>Path:<br>api\task_queue\queued_task.h</p>
</blockquote>
<h3 id="2-1-1-类声明"><a href="#2-1-1-类声明" class="headerlink" title="2.1.1. 类声明"></a>2.1.1. 类声明</h3><div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">namespace</span> webrtc&#123;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">QueuedTask</span>&#123;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">QueuedTask</span>() = <span class="keyword">default</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">bool</span> <span class="title">Run</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;<span class="comment">// class QueuedTask</span></span><br><span class="line">&#125; <span class="comment">// namespace webrtc</span></span><br></pre></td></tr></table></figure></div>

<p><code>QueueTask</code>是一个抽象类，为需要异步执行的任务提供基本接口。<br>这个接口由一个单一的函数 <code>Run()</code>组成，它会在目标队列上执行，<code>Run()</code>具体实现的功能由其子类决定。</p>
<h2 id="2-2-TaskQueueBase类"><a href="#2-2-TaskQueueBase类" class="headerlink" title="2.2. TaskQueueBase类"></a>2.2. <code>TaskQueueBase</code>类</h2><blockquote>
<p>Path:<br>api\task_queue\task_queue_base.h<br>api\task_queue\task_queue_base.cc</p>
</blockquote>
<h3 id="2-2-1-类声明"><a href="#2-2-1-类声明" class="headerlink" title="2.2.1. 类声明"></a>2.2.1. 类声明</h3><div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">namespace</span> webrtc&#123;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">RTC_LOCKABLE</span> RTC_EXPORT TaskQueueBase &#123;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Delete</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">PostTask</span><span class="params">(std::unique_ptr&lt;QueuedTask&gt; task)</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">PostDelayedTask</span><span class="params">(std::unique_ptr&lt;QueuedTask&gt; task,</span></span></span><br><span class="line"><span class="params"><span class="function">                                 <span class="type">uint32_t</span> milliseconds)</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="type">static</span> TaskQueueBase* <span class="title">Current</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">IsCurrent</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> Current == <span class="keyword">this</span>; &#125;</span><br><span class="line">  <span class="keyword">protected</span>:</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">CurrentTaskQueueSetter</span>&#123;</span><br><span class="line">      <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="keyword">explicit</span> <span class="title">CurrentTaskQueueSetter</span><span class="params">(TaskQueueBase* task_queue)</span></span>;</span><br><span class="line">        <span class="built_in">CurrentTaskQueueSetter</span>(<span class="type">const</span> CurrentTaskQueueSetter&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">        CurrentTaskQueueSetter&amp; <span class="keyword">operator</span>=(<span class="type">const</span> CurrentTaskQueueSetter&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">        ~<span class="built_in">CurrentTaskQueueSetter</span>();</span><br><span class="line">      <span class="keyword">private</span>:</span><br><span class="line">        TaskQueueBase* <span class="type">const</span> previous_;</span><br><span class="line">    &#125;;<span class="comment">// class CurrentTaskQueueSetter</span></span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">TaskQueueBase</span>() = <span class="keyword">default</span>;</span><br><span class="line">  </span><br><span class="line">&#125;;<span class="comment">// class TaskQueueBase</span></span><br><span class="line">&#125; <span class="comment">// namespace webrtc</span></span><br></pre></td></tr></table></figure></div>

<h3 id="2-2-2-函数实现及相关说明"><a href="#2-2-2-函数实现及相关说明" class="headerlink" title="2.2.2. 函数实现及相关说明"></a>2.2.2. 函数实现及相关说明</h3><h4 id="2-2-2-1-Delete"><a href="#2-2-2-1-Delete" class="headerlink" title="2.2.2.1. Delete"></a>2.2.2.1. <code>Delete</code></h4><div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Delete</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br></pre></td></tr></table></figure></div>

<p>纯虚函数，基类中无需实现。<br>调用此函数开始销毁任务队列，此函数在返回时需要确保没有任务正在运行，也没有新的任务能够在任务队列中启动。<br>同时此函数负责释放对象，释放动作可以在 <code>Delete</code>期间同步进行，也可以在 <code>Delete</code>之后异步进行。<br>销毁某个任务队列对不在此任务队列中的任务不产生任何影响，这些任务也不会因为其他的任务队列销毁而调用任何函数。<br>在任务队列上执行的任务不可以调用 <code>Delete</code>,但是可以调用其他的函数，比如 <code>PostTask</code>。</p>
<h4 id="2-2-2-2-PostTask"><a href="#2-2-2-2-PostTask" class="headerlink" title="2.2.2.2. PostTask"></a>2.2.2.2. <code>PostTask</code></h4><div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">PostTask</span><span class="params">(std::unique_ptr&lt;QueuedTask&gt; task)</span> </span>= <span class="number">0</span>;</span><br></pre></td></tr></table></figure></div>

<p>纯虚函数，基类中无需实现。<br>此函数用于安排一个即时任务的处理，这些任务按照先进先出的顺序执行（所以称为任务队列）。<br>如果 <code>task-&gt;Run()</code>的返回值是 <code>true</code>,代表任务成功执行，任务会在下一个 <code>QueuedTask</code>开始执行之前从任务队列中被移除。</p>
<h4 id="2-2-2-3-PostDelayTask"><a href="#2-2-2-3-PostDelayTask" class="headerlink" title="2.2.2.3. PostDelayTask"></a>2.2.2.3. <code>PostDelayTask</code></h4><div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">PostDelayedTask</span><span class="params">(std::unique_ptr&lt;QueuedTask&gt; task, </span></span></span><br><span class="line"><span class="params"><span class="function">                                           <span class="type">uint32_t</span> milliseconds)</span> </span>= <span class="number">0</span>;</span><br></pre></td></tr></table></figure></div>

<p>纯虚函数，基类中无需实现。<br>此函数用于安排一个延迟任务的处理，处理会在调用 <code>PostDelayedTask</code>函数后的 <code>milliseconds</code>毫秒后执行。<br>关于延迟时间的精度可以称作“尽力而为”，在某些场景下，定时可能会有一些毫秒级的误差。</p>
<h4 id="2-2-2-4-Current和-IsCurrent"><a href="#2-2-2-4-Current和-IsCurrent" class="headerlink" title="2.2.2.4. Current和 IsCurrent"></a>2.2.2.4. <code>Current</code>和 <code>IsCurrent</code></h4><p>需要说明的是，从此处开始，相关的的定义会根据所定义的宏而不同，代码块中会给出相关说明。<br>变量及函数声明：</p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> TaskQueueBase* <span class="title">Current</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">IsCurrent</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> <span class="built_in">Current</span>() == <span class="keyword">this</span>; &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//if defined ABSL_HAVE_THREAD_LOCAL</span></span><br><span class="line">ABSL_CONST_INIT <span class="keyword">thread_local</span> TaskQueueBase* current = <span class="literal">nullptr</span>;</span><br></pre></td></tr></table></figure></div>

<p><code>Current()</code>函数定义：</p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// defined ABSL_HAVE_THREAD_LOCAL</span></span><br><span class="line"><span class="function">TaskQueueBase* <span class="title">TaskQueueBase::Current</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> current;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// defined WEBRTC_POSIX</span></span><br><span class="line"><span class="function">TaskQueueBase* <span class="title">TaskQueueBase::Current</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">static_cast</span>&lt;TaskQueueBase*&gt;(<span class="built_in">pthread_getspecific</span>(<span class="built_in">GetQueuePtrTls</span>()));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p><code>Current()</code>函数返回当前线程保存的任务队列，返回值为一个 <code>static</code>变量。<br><code>IsCurrent()</code>函数则用于判断当前线程保存的任务队列是不是对象本身。</p>
<h3 id="2-2-3-说明"><a href="#2-2-3-说明" class="headerlink" title="2.2.3. 说明"></a>2.2.3. 说明</h3><ul>
<li><code>TaskQueueBase</code>是抽象基类，只用于提供接口，不可以被实例化</li>
<li>基于上一条说明，<code>TaskQueueBase</code>的析构函数被声明为虚函数</li>
<li>考虑到文章结构，<code>TaskQueueBase</code>的成员类会在下一节介绍</li>
</ul>
<h2 id="2-3-TaskQueue-CurrentTaskQueueSetter类"><a href="#2-3-TaskQueue-CurrentTaskQueueSetter类" class="headerlink" title="2.3. TaskQueue::CurrentTaskQueueSetter类"></a>2.3. <code>TaskQueue::CurrentTaskQueueSetter</code>类</h2><blockquote>
<p>Path:<br>api\task_queue\task_queue_base.h<br>api\task_queue\task_queue_base.cc</p>
</blockquote>
<h3 id="2-3-1-类声明"><a href="#2-3-1-类声明" class="headerlink" title="2.3.1. 类声明"></a>2.3.1. 类声明</h3><div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">namespace</span> webrtc &#123;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">RTC_LOCKABLE</span> RTC_EXPORT TaskQueueBase &#123;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">  <span class="keyword">class</span> <span class="title class_">RTC_EXPORT</span> CurrentTaskQueueSetter &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">CurrentTaskQueueSetter</span><span class="params">(TaskQueueBase* task_queue)</span></span>;</span><br><span class="line">    <span class="built_in">CurrentTaskQueueSetter</span>(<span class="type">const</span> CurrentTaskQueueSetter&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">    CurrentTaskQueueSetter&amp; <span class="keyword">operator</span>=(<span class="type">const</span> CurrentTaskQueueSetter&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">    ~<span class="built_in">CurrentTaskQueueSetter</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">    TaskQueueBase* <span class="type">const</span> previous_;</span><br><span class="line">  &#125;;<span class="comment">// class CurrentTaskQueueSetter</span></span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;;<span class="comment">// class TaskQueueBase</span></span><br><span class="line">&#125;<span class="comment">// namespace webrtc</span></span><br></pre></td></tr></table></figure></div>

<h3 id="2-3-2-函数实现及相关说明"><a href="#2-3-2-函数实现及相关说明" class="headerlink" title="2.3.2.函数实现及相关说明"></a>2.3.2.函数实现及相关说明</h3><h4 id="2-3-2-1-CurrentTaskQueueSetter"><a href="#2-3-2-1-CurrentTaskQueueSetter" class="headerlink" title="2.3.2.1. CurrentTaskQueueSetter"></a>2.3.2.1. <code>CurrentTaskQueueSetter</code></h4><div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// defined ABSL_HAVE_THREAD_LOCAL</span></span><br><span class="line">TaskQueueBase::CurrentTaskQueueSetter::<span class="built_in">CurrentTaskQueueSetter</span>(</span><br><span class="line">    TaskQueueBase* task_queue)</span><br><span class="line">    : <span class="built_in">previous_</span>(current) &#123;</span><br><span class="line">  current = task_queue;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// defined WEBRTC_POSIX</span></span><br><span class="line">TaskQueueBase::CurrentTaskQueueSetter::<span class="built_in">CurrentTaskQueueSetter</span>(</span><br><span class="line">    TaskQueueBase* task_queue)</span><br><span class="line">    : <span class="built_in">previous_</span>(TaskQueueBase::<span class="built_in">Current</span>()) &#123;</span><br><span class="line">  <span class="built_in">pthread_setspecific</span>(<span class="built_in">GetQueuePtrTls</span>(), task_queue);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>构造函数主要的任务分为两部分：</p>
<ul>
<li>使用 <code>previous_</code>暂存当前线程的任务队列</li>
<li>将 <code>task_queue</code>存放在当前线程的 <code>Tls</code>中</li>
</ul>
<h4 id="2-3-2-2-CurrentTaskQueueSetter"><a href="#2-3-2-2-CurrentTaskQueueSetter" class="headerlink" title="2.3.2.2. ~CurrentTaskQueueSetter"></a>2.3.2.2. <code>~CurrentTaskQueueSetter</code></h4><div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// defined ABSL_HAVE_THREAD_LOCAL</span></span><br><span class="line">TaskQueueBase::CurrentTaskQueueSetter::~<span class="built_in">CurrentTaskQueueSetter</span>() &#123;</span><br><span class="line">  current = previous_;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// defined WEBRTC_POSIX</span></span><br><span class="line">TaskQueueBase::CurrentTaskQueueSetter::~<span class="built_in">CurrentTaskQueueSetter</span>() &#123;</span><br><span class="line">  <span class="built_in">pthread_setspecific</span>(<span class="built_in">GetQueuePtrTls</span>(), previous_);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>构造函数的任务就是将之前暂存在 <code>previous_</code>的任务队列取出，重新放回到当前线程的 <code>Tls</code>当中。</p>
<h3 id="2-3-3-说明"><a href="#2-3-3-说明" class="headerlink" title="2.3.3.说明"></a>2.3.3.说明</h3><p><code>CurrentTaskQueueSetter</code>类只在构造和析构时执行任务：</p>
<ul>
<li>构造时，用传入构造函数的任务队列更新当前线程存放的任务队列，并将更新前的任务队列暂存</li>
<li>析构时，用构造时暂存的任务队列更新当前线程存放的任务队列</li>
</ul>
<h1 id="3-总结"><a href="#3-总结" class="headerlink" title="3. 总结"></a>3. 总结</h1><p><code>TaskQueueBase</code>类作为任务队列机制的核心基类，在后续分析中经常会涉及到，了解其实现方法有助于了解整个任务队列的运行机制。<br>关于任务队列的其他类，后续会在其他文章中进行分析。</p>
]]></content>
      <tags>
        <tag>WebRTC</tag>
      </tags>
  </entry>
  <entry>
    <title>WebRTC源码分析之任务队列-TaskQueueStdlib</title>
    <url>/2022/12/06/WebRTC%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E4%B9%8B%E4%BB%BB%E5%8A%A1%E9%98%9F%E5%88%97-TaskQueueStdlib/</url>
    <content><![CDATA[<h1 id="1-前言"><a href="#1-前言" class="headerlink" title="1. 前言"></a>1. 前言</h1><p><code>TaskQueueStdlib</code>类是WebRTC任务队列机制的核心类，也是整个任务队列的标准库，在阅读本文之前，需要对 <code>TaskQueueBase</code>类有一定了解。<br>可以参考这篇文章<a href="https://shis-zhi.github.io/2022/12/06/WebRTC%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E4%B9%8B%E4%BB%BB%E5%8A%A1%E9%98%9F%E5%88%97-TaskQueueBase/">WebRTC源码分析-TaskQueue（任务队列）-TaskQueueBase</a><br>WebRTC版本：M84</p>
<h1 id="2-正文"><a href="#2-正文" class="headerlink" title="2. 正文"></a>2. 正文</h1><h2 id="2-0-预说明：TaskQueuePriorityToThreadPriority"><a href="#2-0-预说明：TaskQueuePriorityToThreadPriority" class="headerlink" title="2.0. 预说明：TaskQueuePriorityToThreadPriority"></a>2.0. 预说明：<code>TaskQueuePriorityToThreadPriority</code></h2><div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">rtc::ThreadPriority <span class="title">TaskQueuePriorityToThreadPriority</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    TaskQueueFactory::Priority priority)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">switch</span> (priority) &#123;</span><br><span class="line">    <span class="keyword">case</span> TaskQueueFactory::Priority::HIGH:</span><br><span class="line">      <span class="keyword">return</span> rtc::kRealtimePriority;</span><br><span class="line">    <span class="keyword">case</span> TaskQueueFactory::Priority::LOW:</span><br><span class="line">      <span class="keyword">return</span> rtc::kLowPriority;</span><br><span class="line">    <span class="keyword">case</span> TaskQueueFactory::Priority::NORMAL:</span><br><span class="line">      <span class="keyword">return</span> rtc::kNormalPriority;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      <span class="built_in">RTC_NOTREACHED</span>();</span><br><span class="line">      <span class="keyword">return</span> rtc::kNormalPriority;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>此函数用于将任务队列的优先级转换为线程的优先级。<br><code>TaskQueueFactory::Priority</code>定义如下：</p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">enum class</span> <span class="title class_">Priority</span> &#123; NORMAL = <span class="number">0</span>, HIGH, LOW &#125;;</span><br></pre></td></tr></table></figure></div>

<h2 id="2-1-TaskQueueStdlib类"><a href="#2-1-TaskQueueStdlib类" class="headerlink" title="2.1. TaskQueueStdlib类"></a>2.1. <code>TaskQueueStdlib</code>类</h2><blockquote>
<p>path:<br>rtc_base\task_queue_stdlib.h<br>rtc_base\task_queue_stdlib.cc</p>
</blockquote>
<h3 id="2-1-1-类声明"><a href="#2-1-1-类声明" class="headerlink" title="2.1.1. 类声明"></a>2.1.1. 类声明</h3><div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">TaskQueueStdlib</span> <span class="keyword">final</span> : <span class="keyword">public</span> TaskQueueBase &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">TaskQueueStdlib</span>(absl::string_view queue_name, rtc::ThreadPriority priority);</span><br><span class="line">  ~<span class="built_in">TaskQueueStdlib</span>() <span class="keyword">override</span> = <span class="keyword">default</span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">Delete</span><span class="params">()</span> <span class="keyword">override</span></span>;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">PostTask</span><span class="params">(std::unique_ptr&lt;QueuedTask&gt; task)</span> <span class="keyword">override</span></span>;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">PostDelayedTask</span><span class="params">(std::unique_ptr&lt;QueuedTask&gt; task,</span></span></span><br><span class="line"><span class="params"><span class="function">                       <span class="type">uint32_t</span> milliseconds)</span> <span class="keyword">override</span></span>;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  <span class="keyword">using</span> OrderId = <span class="type">uint64_t</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">DelayedEntryTimeout</span> &#123;</span><br><span class="line">    <span class="type">int64_t</span> next_fire_at_ms_&#123;&#125;;</span><br><span class="line">    OrderId order_&#123;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span>&lt;(<span class="type">const</span> DelayedEntryTimeout&amp; o) <span class="type">const</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> std::<span class="built_in">tie</span>(next_fire_at_ms_, order_) &lt;</span><br><span class="line">             std::<span class="built_in">tie</span>(o.next_fire_at_ms_, o.order_);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">NextTask</span> &#123;</span><br><span class="line">    <span class="type">bool</span> final_task_&#123;<span class="literal">false</span>&#125;;</span><br><span class="line">    std::unique_ptr&lt;QueuedTask&gt; run_task_;</span><br><span class="line">    <span class="type">int64_t</span> sleep_time_ms_&#123;&#125;;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="function">NextTask <span class="title">GetNextTask</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">ThreadMain</span><span class="params">(<span class="type">void</span>* context)</span></span>;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">ProcessTasks</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">NotifyWake</span><span class="params">()</span></span>;</span><br><span class="line">  rtc::Event started_;</span><br><span class="line">  rtc::Event stopped_;</span><br><span class="line">  rtc::Event flag_notify_;</span><br><span class="line">  rtc::PlatformThread thread_;</span><br><span class="line">  rtc::CriticalSection pending_lock_;</span><br><span class="line">  <span class="function"><span class="type">bool</span> thread_should_quit_ <span class="title">RTC_GUARDED_BY</span><span class="params">(pending_lock_)</span></span>&#123;<span class="literal">false</span>&#125;;</span><br><span class="line">  <span class="function">OrderId thread_posting_order_ <span class="title">RTC_GUARDED_BY</span><span class="params">(pending_lock_)</span></span>&#123;&#125;;</span><br><span class="line">  std::queue&lt;std::pair&lt;OrderId, std::unique_ptr&lt;QueuedTask&gt;&gt;&gt; <span class="function">pending_queue_</span></span><br><span class="line"><span class="function">      <span class="title">RTC_GUARDED_BY</span><span class="params">(pending_lock_)</span></span>;</span><br><span class="line">  std::map&lt;DelayedEntryTimeout, std::unique_ptr&lt;QueuedTask&gt;&gt; <span class="function">delayed_queue_</span></span><br><span class="line"><span class="function">      <span class="title">RTC_GUARDED_BY</span><span class="params">(pending_lock_)</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div>

<p>可以看出 <code>TaskQueueStdlib</code>的 <code>public</code>成员除构造函数和析构函数之外只有三个函数，<code>private</code>成员都是为了实现 <code>public</code>方法而定义的，所以后续会先分析其私有成员，最后再分析三个 <code>public</code>成员函数的具体实现方式。</p>
<h3 id="2-1-2-私有成员实现"><a href="#2-1-2-私有成员实现" class="headerlink" title="2.1.2. 私有成员实现"></a>2.1.2. 私有成员实现</h3><p>此处使用 <code>using</code>语句，类似于 <code>typedef</code>，类型 <code>OrderId</code>实际上就是 <code>uint64_t</code>。</p>
<h4 id="2-1-2-1-私有数据成员"><a href="#2-1-2-1-私有数据成员" class="headerlink" title="2.1.2.1. 私有数据成员"></a>2.1.2.1. 私有数据成员</h4><div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 表示该线程是否已经开始</span></span><br><span class="line">rtc::Event started_;</span><br><span class="line"><span class="comment">// 表示该线程是否已经结束</span></span><br><span class="line">rtc::Event stopped_;</span><br><span class="line"><span class="comment">// 每当有新的任务等待时，就会发出信号</span></span><br><span class="line">rtc::Event flag_notify_;</span><br><span class="line"><span class="comment">// 表示被分配用于处理任务的活动工作线程</span></span><br><span class="line">rtc::PlatformThread thread_;</span><br><span class="line"><span class="comment">// 对于存在多个线程访问的数据需要上锁</span></span><br><span class="line">rtc::CriticalSection pending_lock_;</span><br><span class="line"><span class="comment">// 表示工作线程是否需要现在关闭</span></span><br><span class="line"><span class="function"><span class="type">bool</span> thread_should_quit_ <span class="title">RTC_GUARDED_BY</span><span class="params">(pending_lock_)</span></span>&#123;<span class="literal">false</span>&#125;;</span><br><span class="line"><span class="comment">// 保存下一个任务的序号，用于将其放入一个挂起的队列中</span></span><br><span class="line"><span class="function">OrderId thread_posting_order_ <span class="title">RTC_GUARDED_BY</span><span class="params">(pending_lock_)</span></span>&#123;&#125;;</span><br><span class="line"><span class="comment">// 需要在工作线程中按照先进先出的队列顺序处理的待办任务列表</span></span><br><span class="line">std::queue&lt;std::pair&lt;OrderId, std::unique_ptr&lt;QueuedTask&gt;&gt;&gt; <span class="function">pending_queue_</span></span><br><span class="line"><span class="function">    <span class="title">RTC_GUARDED_BY</span><span class="params">(pending_lock_)</span></span>;</span><br><span class="line"><span class="comment">// 需要在工作线程中延迟一段时间再处理的待办任务列表，如果两个任务在相同的时间间隔内</span></span><br><span class="line"><span class="comment">// 发生，那么将根据先后顺序进行处理。</span></span><br><span class="line">std::map&lt;DelayedEntryTimeout, std::unique_ptr&lt;QueuedTask&gt;&gt; <span class="function">delayed_queue_</span></span><br><span class="line"><span class="function">    <span class="title">RTC_GUARDED_BY</span><span class="params">(pending_lock_)</span></span>;</span><br></pre></td></tr></table></figure></div>

<h4 id="2-1-2-2-私有成员类-amp-结构"><a href="#2-1-2-2-私有成员类-amp-结构" class="headerlink" title="2.1.2.2. 私有成员类&amp;结构"></a>2.1.2.2. 私有成员类&amp;结构</h4><div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">DelayedEntryTimeout</span> &#123;</span><br><span class="line">  <span class="type">int64_t</span> next_fire_at_ms_&#123;&#125;;</span><br><span class="line">  OederId order_&#123;&#125;;</span><br><span class="line">  </span><br><span class="line">  <span class="type">bool</span> <span class="keyword">operator</span>&lt;(<span class="type">const</span> DelayedEntryTimeout&amp; o) <span class="type">const</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> std::<span class="built_in">tie</span>(next_fire_at_ms_, order_) &lt; </span><br><span class="line">           std::<span class="built_in">tie</span>(o.next_fire_at_ms_, o.order_);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div>

<p><code>DelayedEntryTimeout</code>具有类似于时间戳的功能，<code>next_fire_at_ms_</code>记录了任务执行的绝对时间，<code>OrderId</code>则记录了任务对应的序号，重载了 <code>&lt;</code>操作符用于比较两个<br><code>DelayedEntryTimeout</code>,该属性较小的任务会先被执行。<br><code>DelayedEntryTimeout</code>比较规则：先比较 <code>next_fire_at_ms_</code>，如果不等直接返回对应的 <code>bool</code>值；如果相等，则再次比较 <code>order</code>,返回比较结果对应的 <code>bool</code>值。</p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">NextTask</span> &#123;</span><br><span class="line">  <span class="type">bool</span> final_task_&#123;<span class="literal">false</span>&#125;;</span><br><span class="line">  std::unique_ptr&lt;QueuedTask&gt; run_task_;</span><br><span class="line">  <span class="type">int64_t</span> sleep_time_ms_&#123;&#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div>

<p><code>NextTask</code>用于表示下一个任务，前两个属性很容易理解，第三个属性是为了兼容 <code>DelayedTask</code>而设置的，具体的实现将会在 <code>GetNextTask</code>函数中介绍到。</p>
<h4 id="2-1-2-3-私有成员函数实现"><a href="#2-1-2-3-私有成员函数实现" class="headerlink" title="2.1.2.3. 私有成员函数实现"></a>2.1.2.3. 私有成员函数实现</h4><h5 id="2-1-2-3-1-GetNextTask"><a href="#2-1-2-3-1-GetNextTask" class="headerlink" title="2.1.2.3.1. GetNextTask"></a>2.1.2.3.1. <code>GetNextTask</code></h5><div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">TaskQueu1Stdlib::NextTask <span class="title">TaskQueueStdlib::GetNextTask</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  NextTask result&#123;&#125;;</span><br><span class="line">  <span class="comment">// 获取当前的绝对时间(ms)</span></span><br><span class="line">  <span class="keyword">auto</span> tick = rtc::<span class="built_in">TimeMillis</span>();</span><br><span class="line"></span><br><span class="line">  <span class="function">rtc::CritScope <span class="title">lock</span><span class="params">(&amp;pending_lock_)</span></span>;</span><br><span class="line">  <span class="comment">// 判断是否线程需要退出</span></span><br><span class="line">  <span class="keyword">if</span> (thread_should_quit_) &#123;</span><br><span class="line">    result.final_task_ = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 如果延迟任务队列非空，则首先从其中取出任务 </span></span><br><span class="line">  <span class="keyword">if</span> (delayed_queue_.<span class="built_in">size</span>() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">// 获取延迟任务相关信息</span></span><br><span class="line">    <span class="keyword">auto</span> delayed_entry = delayed_queue_.<span class="built_in">begin</span>();</span><br><span class="line">    <span class="type">const</span> <span class="keyword">auto</span>&amp; delay_info = delayed_entry-&gt;first;</span><br><span class="line">    <span class="keyword">auto</span>&amp; delay_run = delayed_entry-&gt;second;</span><br><span class="line">    <span class="comment">// 判断是否应该执行延迟任务</span></span><br><span class="line">    <span class="keyword">if</span> (tick &gt;= delay_info.next_fire_at_ms_) &#123;</span><br><span class="line">      <span class="comment">// 如果即时任务队列非空，通过比较决定取出哪种任务</span></span><br><span class="line">      <span class="keyword">if</span> (pending_queue_.<span class="built_in">size</span>() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">auto</span>&amp; entry = pending_queue_.<span class="built_in">front</span>();</span><br><span class="line">        <span class="keyword">auto</span>&amp; entry_order = entry.first;</span><br><span class="line">        <span class="keyword">auto</span>&amp; entry_run = entry.second;</span><br><span class="line">        <span class="comment">// 如果即时任务序号较小，则直接返回该即时任务 </span></span><br><span class="line">        <span class="keyword">if</span> (entry_order &lt; delay_info.order_) &#123;  </span><br><span class="line">          result.run_task_ = std::<span class="built_in">move</span>(entry_run);              <span class="comment">//&lt;--1</span></span><br><span class="line">          pending_queue_.<span class="built_in">pop</span>();</span><br><span class="line">          <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 如果即时任务队列为空，或者1处即时任务序号较大，则取出最靠前的延迟任务</span></span><br><span class="line">      result.run_task_ = std::<span class="built_in">move</span>(delay_run);                  <span class="comment">//&lt;--2</span></span><br><span class="line">      delayed_queue_.<span class="built_in">erase</span>(delayed_entry);</span><br><span class="line">      <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ！！如果运行到这里，此时result.task_run_为nullptr，表明没有任务需要处理</span></span><br><span class="line">    <span class="comment">// 更新sleep_time_ms_</span></span><br><span class="line">    result.sleep_time_ms_ = delay_info.next_fire_at_ms_ - tick; <span class="comment">//&lt;--3</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 延迟任务队列为空，即时任务队列非空</span></span><br><span class="line">  <span class="keyword">if</span> (pending_queue_.<span class="built_in">size</span>() &gt; <span class="number">0</span>) &#123;   </span><br><span class="line">    <span class="keyword">auto</span>&amp; entry = pending_queue_.<span class="built_in">front</span>();                       <span class="comment">//&lt;--4</span></span><br><span class="line">    result.run_task_ = std::<span class="built_in">move</span>(entry.second);</span><br><span class="line">    pending_queue_.<span class="built_in">pop</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>其中涉及到 <code>map</code>和 <code>queue</code>两个容器的相关函数，可以自行查阅。<br>由于 <code>NextTask</code>结构体内部的 <code>run_task_</code>为 <code>unique_ptr</code>，所以不能直接赋值而是使用 <code>std::move</code>转移所有权。</p>
<p><code>GetNextTask</code>函数体较长，逻辑略显复杂，而且非常重要，一定要理清楚如何从任务队列中取出任务。<br>代码块里做了四处标记，便于理解整个流程（此处分析认为 <code>thread_should_quit_</code>为 <code>true</code>）：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">if 延迟任务队列非空</span><br><span class="line">  if 需要执行下一个延迟任务</span><br><span class="line">    if 即时任务队列非空</span><br><span class="line">      if 即时任务序号较小</span><br><span class="line">        返回即时任务(1)</span><br><span class="line">      else </span><br><span class="line">        返回延迟任务(2)</span><br><span class="line">    else</span><br><span class="line">      返回延迟任务(2)</span><br><span class="line">  else</span><br><span class="line">    更新result.sleep_time_ms_(3)</span><br><span class="line">if 即时任务队列非空</span><br><span class="line">  result.run_task_设置为即时任务(4)</span><br><span class="line">返回result</span><br></pre></td></tr></table></figure></div>

<p>这一部分可以概括为：</p>
<ul>
<li><code>result.run_task_</code>为空，<code>result.sleep_time_ms_</code>为0时：两个任务队列均为空</li>
<li><code>result.run_task_</code>为空，<code>result.sleep_time_ms_</code>不为0时：即时任务队列为空，延迟任务队列非空，但是没有可执行的延迟任务</li>
<li><code>result.run_task_</code>不为空，<code>result.sleep_time_ms_</code>为0时：即时任务队列非空，延迟任务队列为空</li>
<li><code>result.run_task_</code>不为空，<code>result.sleep_time_ms_</code>不为0时：即时任务队列非空，延迟任务队列非空，但是没有可执行的延迟任务</li>
</ul>
<h5 id="2-1-2-3-2-ThreadMain"><a href="#2-1-2-3-2-ThreadMain" class="headerlink" title="2.1.2.3.2 ThreadMain"></a>2.1.2.3.2 <code>ThreadMain</code></h5><div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// static</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">TaskQueueStdlib::ThreadMain</span><span class="params">(<span class="type">void</span>* context)</span> </span>&#123;</span><br><span class="line">  TaskQueueStdlib* me = <span class="built_in">static_cast</span>&lt;TaskQueueStdlib*&gt;(context);</span><br><span class="line">  <span class="function">CurrentTaskQueueSetter <span class="title">set_current</span><span class="params">(me)</span></span>;</span><br><span class="line">  me-&gt;<span class="built_in">ProcessTasks</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p><code>ThreadMain</code>是任务处理线程真正的入口函数，其首先将传入的参数强制转换成 <code>TaskQueueStdlib*</code>,然后将这个任务队列注册到当前的线程中，随后开始处理任务。<br>注意此函数是一个 <code>static</code>函数。</p>
<h5 id="2-1-2-3-3-ProcessTasks"><a href="#2-1-2-3-3-ProcessTasks" class="headerlink" title="2.1.2.3.3. ProcessTasks"></a>2.1.2.3.3. <code>ProcessTasks</code></h5><div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">TaskQueueStdlib::ProcessTasks</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  started_.<span class="built_in">Set</span>();</span><br><span class="line">  <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="keyword">auto</span> task = <span class="built_in">GetNextTask</span>();</span><br><span class="line">    <span class="keyword">if</span> (task.final_task_)</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">if</span> (task.run_task_) &#123;</span><br><span class="line">      <span class="comment">// release()会解除智能指针对这个QueuedTask的占用，</span></span><br><span class="line">      <span class="comment">// 并将该智能指针置空</span></span><br><span class="line">      QueuedTask* release_ptr = task.run_task_.<span class="built_in">release</span>();</span><br><span class="line">      <span class="keyword">if</span> (release_ptr-&gt;<span class="built_in">Run</span>())</span><br><span class="line">        <span class="keyword">delete</span> release_ptr;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 取出下一个任务</span></span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// task.sleep_time_ms_为0时表示</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="number">0</span> == task.sleep_time_ms_)</span><br><span class="line">      flag_notify_.<span class="built_in">Wait</span>(rtc::Event::kForever);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      flag_notify_.<span class="built_in">Wait</span>(task.sleep_time_ms_);</span><br><span class="line">  &#125;</span><br><span class="line">  stopped_.<span class="built_in">Set</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p><code>ProcessTasks</code>函数与 <code>GetNextTask</code>函数协同工作。由 <code>GetNextTask</code>函数部分的分析可知只要 <code>task.run_task_</code>为空，就说明即时任务队列为空且暂时没有需要执行的任务，但此时又面临着两种情况：</p>
<ul>
<li>如果延迟任务队列为空，那么直接睡眠直到被唤起</li>
<li>如果延迟任务队列非空，那么将会睡眠指定时间</li>
</ul>
<h5 id="2-1-2-3-4-NotifyWake"><a href="#2-1-2-3-4-NotifyWake" class="headerlink" title="2.1.2.3.4. NotifyWake"></a>2.1.2.3.4. <code>NotifyWake</code></h5><div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">TaskQueueStdlib::NotifyWake</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  flag_notify_.<span class="built_in">Set</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>任务队列中存放着待执行的任务：</p>
<ul>
<li>对于即时任务，线程会忙于执行该任务而不会等待 <code>flag_notify_</code>事件。</li>
<li>如果没有即时任务，但有一个延迟任务正在等待，那么线程将会等待 <code>flag_notify_</code>事件，也就是 <code>ProcessTasks</code>中所提及到的 <code>flag_notify_.Wait(task.sleep_time_ms_);</code></li>
<li>如果即时任务队列和延迟任务队列都为空，那么线程将无限期等待 <code>flag_notify_</code>事件，直到有一个信号显示有新的任务被添加（或者告诉线程需要终止）。</li>
</ul>
<p>任何情况下，当一个新的上述请求被添加后，会发出 <code>flag_notify_</code>信号。如果此时线程正在等待，则会被立即唤醒并且重新评估下一步需要做什么。如果线程并没有在等待，那么线程将保持信号，在下一次试图等待 <code>flag_notify_</code>事件发生时被唤醒。</p>
<p>在发出 <code>flag_notify_</code>信号来唤醒可能正在睡眠的线程之前，需要确保有任务或相关请求添加到队列中，从而避免竞争情况：线程被通知唤醒但是发现没有任务需要执行，所以会再次等待信号，然而这样的信号将有可能不会再次出现。</p>
<h3 id="2-1-3-公有成员实现"><a href="#2-1-3-公有成员实现" class="headerlink" title="2.1.3. 公有成员实现"></a>2.1.3. 公有成员实现</h3><h4 id="2-1-3-1-公有成员函数实现"><a href="#2-1-3-1-公有成员函数实现" class="headerlink" title="2.1.3.1. 公有成员函数实现"></a>2.1.3.1. 公有成员函数实现</h4><h5 id="2-1-3-1-1-TaskQueueStdlib"><a href="#2-1-3-1-1-TaskQueueStdlib" class="headerlink" title="2.1.3.1.1. TaskQueueStdlib"></a>2.1.3.1.1. <code>TaskQueueStdlib</code></h5><div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line">TaskQueueStdlib::<span class="built_in">TaskQueueStdlib</span>(absl::string_view queue_name,</span><br><span class="line">                                 rtc::ThreadPriority priority)</span><br><span class="line">    : <span class="built_in">started_</span>(<span class="comment">/*manual_reset=*/</span><span class="literal">false</span>, <span class="comment">/*initially_signaled=*/</span><span class="literal">false</span>),</span><br><span class="line">      <span class="built_in">stopped_</span>(<span class="comment">/*manual_reset=*/</span><span class="literal">false</span>, <span class="comment">/*initially_signaled=*/</span><span class="literal">false</span>),</span><br><span class="line">      <span class="built_in">flag_notify_</span>(<span class="comment">/*manual_reset=*/</span><span class="literal">false</span>, <span class="comment">/*initially_signaled=*/</span><span class="literal">false</span>),</span><br><span class="line">      <span class="built_in">thread_</span>(&amp;TaskQueueStdlib::ThreadMain, <span class="keyword">this</span>, queue_name, priority) &#123;</span><br><span class="line">  thread_.<span class="built_in">Start</span>();</span><br><span class="line">  started_.<span class="built_in">Wait</span>(rtc::Event::kForever);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>创建一个任务处理线程，随后开始执行入口函数并挂起当前线程。<br>当任务处理线程准备就绪之后，会唤醒当前线程。<br>当前线程负责创建一个任务处理线程并且向其投递任务，任务处理线程负责处理任务队列内的任务。</p>
<h5 id="2-1-3-1-2-Delete"><a href="#2-1-3-1-2-Delete" class="headerlink" title="2.1.3.1.2.Delete"></a>2.1.3.1.2.<code>Delete</code></h5><div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">TaskQueueStdlib::Delete</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">RTC_DCHECK</span>(!<span class="built_in">IsCurrent</span>());</span><br><span class="line"></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="function">rtc::CritScope <span class="title">lock</span><span class="params">(&amp;pending_lock_)</span></span>;</span><br><span class="line">    thread_should_quit_ = <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">NotifyWake</span>();</span><br><span class="line"></span><br><span class="line">  stopped_.<span class="built_in">Wait</span>(rtc::Event::kForever);</span><br><span class="line">  thread_.<span class="built_in">Stop</span>();</span><br><span class="line">  <span class="keyword">delete</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>此函数用于销毁任务队列对象：</p>
<ul>
<li>首先判断当前线程是不是任务处理线程，因为销毁操作不可以在任务处理线程中进行</li>
<li>随后标记任务处理线程需要退出并唤醒线程执行相关任务</li>
<li>然后当前线程等待任务处理线程退出后唤醒主线程</li>
<li>主线程回收任务处理线程，最后释放任务队列对象</li>
</ul>
<h5 id="2-1-3-1-3-PostTask"><a href="#2-1-3-1-3-PostTask" class="headerlink" title="2.1.3.1.3. PostTask"></a>2.1.3.1.3. <code>PostTask</code></h5><div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">TaskQueueStdlib::PostTask</span><span class="params">(std::unique_ptr&lt;QueuedTask&gt; task)</span> </span>&#123;</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="function">rtc::CritScope <span class="title">lock</span><span class="params">(&amp;pending_lock_)</span></span>;</span><br><span class="line">    <span class="comment">// 序号自增赋值</span></span><br><span class="line">    OrderId order = thread_posting_order_++;</span><br><span class="line">    <span class="comment">// 加入到即时任务队列中</span></span><br><span class="line">    pending_queue_.<span class="built_in">push</span>(std::pair&lt;OrderId, std::unique_ptr&lt;QueuedTask&gt;&gt;(</span><br><span class="line">        order, std::<span class="built_in">move</span>(task)));</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 唤醒任务处理线程处理任务</span></span><br><span class="line">  <span class="built_in">NotifyWake</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h5 id="2-1-3-1-4-PostDelayedTask"><a href="#2-1-3-1-4-PostDelayedTask" class="headerlink" title="2.1.3.1.4. PostDelayedTask"></a>2.1.3.1.4. <code>PostDelayedTask</code></h5><div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">TaskQueueStdlib::PostDelayedTask</span><span class="params">(std::unique_ptr&lt;QueuedTask&gt; task,</span></span></span><br><span class="line"><span class="params"><span class="function">                                      <span class="type">uint32_t</span> milliseconds)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 计算延迟任务的执行时间（绝对时间）</span></span><br><span class="line">  <span class="keyword">auto</span> fire_at = rtc::<span class="built_in">TimeMillis</span>() + milliseconds;</span><br><span class="line"></span><br><span class="line">  DelayedEntryTimeout delay;</span><br><span class="line">  <span class="comment">// 设置延迟任务的执行时间</span></span><br><span class="line">  delay.next_fire_at_ms_ = fire_at;</span><br><span class="line"></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="function">rtc::CritScope <span class="title">lock</span><span class="params">(&amp;pending_lock_)</span></span>;</span><br><span class="line">    <span class="comment">// 序号自增赋值</span></span><br><span class="line">    delay.order_ = ++thread_posting_order_;</span><br><span class="line">    delayed_queue_[delay] = std::<span class="built_in">move</span>(task);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 唤醒任务处理线程处理任务</span></span><br><span class="line">  <span class="built_in">NotifyWake</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h1 id="3-总结"><a href="#3-总结" class="headerlink" title="3. 总结"></a>3. 总结</h1><p><code>TaskQueueStdlib</code>涉及到任务队列的核心实现方式，尤其是 <code>GetNextTask</code>和 <code>ProcessTasks</code>两个函数，需要理清相关的逻辑，从而了解整个模块的流程。</p>
]]></content>
      <tags>
        <tag>WebRTC</tag>
      </tags>
  </entry>
</search>
