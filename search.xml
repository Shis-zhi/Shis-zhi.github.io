<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>C++关键字之explicit</title>
    <url>/2022/12/06/C++%E5%85%B3%E9%94%AE%E5%AD%97%E4%B9%8Bexplicit/</url>
    <content><![CDATA[<p>在C++中 <code>explicit</code>关键字只能用来修饰单参构造函数。</p>
<p>与之对应的关键字为 <code>implicit</code>，其含义为“隐式的”，类的构造函数默认声明为 <code>implicit</code>。</p>
<h2 id="1-隐式声明的构造函数"><a href="#1-隐式声明的构造函数" class="headerlink" title="1. 隐式声明的构造函数"></a>1. 隐式声明的构造函数</h2><div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">CxString</span></span><br><span class="line">&#123;  </span><br><span class="line"><span class="keyword">public</span>:  </span><br><span class="line">    <span class="type">char</span> *_pstr;  </span><br><span class="line">    <span class="type">int</span> _size;  </span><br><span class="line">    <span class="built_in">CxString</span>(<span class="type">int</span> size)  </span><br><span class="line">    &#123;  </span><br><span class="line">        _size = size;                       <span class="comment">// string的预设大小  </span></span><br><span class="line">        _pstr = (<span class="type">char</span>*)<span class="built_in">malloc</span>(size + <span class="number">1</span>);    <span class="comment">// 分配string的内存  </span></span><br><span class="line">        <span class="built_in">memset</span>(_pstr, <span class="number">0</span>, size + <span class="number">1</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="built_in">CxString</span>(<span class="type">const</span> <span class="type">char</span> *p)  </span><br><span class="line">    &#123;  </span><br><span class="line">        <span class="type">int</span> size = <span class="built_in">strlen</span>(p);  </span><br><span class="line">        _pstr = (<span class="type">char</span>*)<span class="built_in">malloc</span>(size + <span class="number">1</span>);    <span class="comment">// 分配string的内存  </span></span><br><span class="line">        <span class="built_in">strcpy</span>(_pstr, p);            <span class="comment">// 复制字符串  </span></span><br><span class="line">        _size = <span class="built_in">strlen</span>(_pstr);  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="comment">// 析构函数这里不讨论, 省略...  </span></span><br><span class="line">&#125;;  </span><br><span class="line"></span><br><span class="line">    <span class="function">CxString <span class="title">string1</span><span class="params">(<span class="number">1</span>)</span></span>;      <span class="comment">// 正确，调用 CxString(int size) </span></span><br><span class="line">    CxString string2 = <span class="number">2</span>;     <span class="comment">// 正确，调用 CxString(int size)   </span></span><br><span class="line">    CxString string3;         <span class="comment">// 错误，无默认的构造函数</span></span><br><span class="line">    <span class="function">CxString <span class="title">string4</span><span class="params">(<span class="string">&quot;123&quot;</span>)</span></span>;  <span class="comment">// 正确，调用 CxString(const char *p) </span></span><br><span class="line">    CxString string5 = <span class="string">&quot;456&quot;</span>; <span class="comment">// 正确，调用 CxString(const char *p) </span></span><br><span class="line">    CxString string6 = <span class="string">&#x27;a&#x27;</span>;   <span class="comment">// 正确，但是调用 CxString(int size)，size的值为&#x27;a&#x27;的ascii码</span></span><br></pre></td></tr></table></figure></div>

<p>在C++中，如果构造函数只有一个参数时，在编译的时候就会有一个缺省的类型转换操作，也就是将对应的数据类型转换为该类对象。所以说：</p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line">CxString string2 = <span class="number">2</span>;</span><br></pre></td></tr></table></figure></div>

<p>实际上等同于：</p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">CxString <span class="title">string2</span><span class="params">(<span class="number">2</span>)</span></span>;</span><br><span class="line"><span class="comment">// 或以下形式</span></span><br><span class="line"><span class="function">CxString <span class="title">tmp</span><span class="params">(<span class="number">2</span>)</span></span>;</span><br><span class="line">CxString string2 = tmp;   </span><br></pre></td></tr></table></figure></div>

<p>关于<code>string6</code>的情况类似，只不过将<code>&#39;a&#39;</code>转化成了对应的ascii码。<br>但是以上两种写法并不具有很好的可读性，为了避免这种情况产生，可以使用<code>explicit</code>关键字阻止隐式的自动类型转换。</p>
<h2 id="2-显式声明的构造函数"><a href="#2-显式声明的构造函数" class="headerlink" title="2.显式声明的构造函数"></a>2.显式声明的构造函数</h2><p>使用<code>explicit</code>关键字可以阻止类构造函数的隐式类型转换。</p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">CxString</span></span><br><span class="line">&#123;  </span><br><span class="line"><span class="keyword">public</span>:  </span><br><span class="line">    <span class="type">char</span> *_pstr;  </span><br><span class="line">    <span class="type">int</span> _size;  </span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">CxString</span><span class="params">(<span class="type">int</span> size)</span>  </span></span><br><span class="line"><span class="function">    </span>&#123;  </span><br><span class="line">        _size = size;                       <span class="comment">// string的预设大小  </span></span><br><span class="line">        _pstr = (<span class="type">char</span>*)<span class="built_in">malloc</span>(size + <span class="number">1</span>);    <span class="comment">// 分配string的内存  </span></span><br><span class="line">        <span class="built_in">memset</span>(_pstr, <span class="number">0</span>, size + <span class="number">1</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="built_in">CxString</span>(<span class="type">const</span> <span class="type">char</span> *p)  </span><br><span class="line">    &#123;  </span><br><span class="line">        <span class="type">int</span> size = <span class="built_in">strlen</span>(p);  </span><br><span class="line">        _pstr = (<span class="type">char</span>*)<span class="built_in">malloc</span>(size + <span class="number">1</span>);    <span class="comment">// 分配string的内存  </span></span><br><span class="line">        <span class="built_in">strcpy</span>(_pstr, p);            <span class="comment">// 复制字符串  </span></span><br><span class="line">        _size = <span class="built_in">strlen</span>(_pstr);  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="comment">// 析构函数这里不讨论, 省略...  </span></span><br><span class="line">&#125;;  </span><br><span class="line">    <span class="function">CxString <span class="title">string1</span><span class="params">(<span class="number">1</span>)</span></span>;      <span class="comment">// 正确，调用 CxString(int size) </span></span><br><span class="line">    CxString string2 = <span class="number">2</span>;     <span class="comment">// 错误  </span></span><br><span class="line">    CxString string3;         <span class="comment">// 错误，无默认的构造函数</span></span><br><span class="line">    <span class="function">CxString <span class="title">string4</span><span class="params">(<span class="string">&quot;123&quot;</span>)</span></span>;  <span class="comment">// 正确，调用 CxString(const char *p) </span></span><br><span class="line">    CxString string5 = <span class="string">&quot;456&quot;</span>; <span class="comment">// 正确，调用 CxString(const char *p)</span></span><br><span class="line">    CxString string6 = <span class="string">&#x27;a&#x27;</span>;   <span class="comment">// 正确，但是调用 CxString(int size)，size的值为&#x27;a&#x27;的ascii码</span></span><br></pre></td></tr></table></figure></div>

<h2 id="3-特殊情况：多参构造函数"><a href="#3-特殊情况：多参构造函数" class="headerlink" title="3.特殊情况：多参构造函数"></a>3.特殊情况：多参构造函数</h2><p>文章开头提到<code>explicit</code>关键字只适用于单参构造函数，因为如果类构造函数的参数大于等于两个时，不会触发隐式类型转换，那么<code>explicit</code>关键字随之无效，但是有一种特殊情况，也就是<strong>除了第一个参数以外的其他参数都有默认值的时候，<code>explicit</code>关键字仍然有效</strong>。</p>
<h2 id="4-总结"><a href="#4-总结" class="headerlink" title="4.总结"></a>4.总结</h2><p><code>explicit</code>关键字只用于声明类的单参构造函数（包括上述特殊情况）。<br>《Effective C++》提到：被声明为<code>explicit</code>的构造函数通常比其<code>non-explicit</code>兄弟更受欢迎。因为它们禁止编译器执行非预期（往往也不被期望）的类型转换。</p>
]]></content>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>C++关键字之constexpr</title>
    <url>/2022/12/06/C++%E5%85%B3%E9%94%AE%E5%AD%97%E4%B9%8Bconstexpr/</url>
    <content><![CDATA[<p><code>constexpr</code>关键字的功能是使指定的常量表达式获得在程序编译阶段计算出结果的能力，而不必等到程序运行阶段。C++ 11 标准中，<code>constexpr</code>可用于修饰普通变量、函数（包括模板函数）以及类的构造函数。</p>
<h2 id="1-constexpr修饰普通变量"><a href="#1-constexpr修饰普通变量" class="headerlink" title="1.constexpr修饰普通变量"></a>1.<code>constexpr</code>修饰普通变量</h2><p>C++11 标准中，定义变量时可以用<code>constexpr</code>修饰，从而使该变量获得在编译阶段即可计算出结果的能力。<br>需要注意的是：使用 constexpr 修饰普通变量时，变量必须经过初始化且初始值必须是一个常量表达式。举个例子：</p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">constexpr</span> <span class="type">int</span> num = <span class="number">1</span> + <span class="number">2</span> + <span class="number">3</span>;</span><br><span class="line">    <span class="type">int</span> url[num] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>&#125;;</span><br><span class="line">    cout&lt;&lt; url[<span class="number">1</span>] &lt;&lt; endl;    <span class="comment">//2</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h2 id="2-constexpr修饰函数"><a href="#2-constexpr修饰函数" class="headerlink" title="2.constexpr修饰函数"></a>2.<code>constexpr</code>修饰函数</h2><p><code>constexpr</code>还可以用于修饰函数的返回值，这样的函数又称为<strong>常量表达式函数</strong>。<br>但是<code>constexpr</code>并不能修饰任意函数的返回值，对于函数有以下几个要求：</p>
<p>一、<strong>整个函数的函数体中，除了可以包含<code>using</code>指令、<code>typedef</code>语句以及<code>static_assert</code>断言外，只能包含一条 <code>return</code>返回语句。</strong><br>对于C++11来说要求如上，但在C++14中解除了对<code>constexpr</code>函数的大部分限制。详情可以查阅相关文档。</p>
  <div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">constexpr</span> <span class="type">int</span> <span class="title">func</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> ret = <span class="number">1</span> + <span class="number">2</span> + x;</span><br><span class="line">  <span class="keyword">return</span> ret;</span><br><span class="line">&#125;<span class="comment">//错误写法</span></span><br><span class="line"><span class="function"><span class="keyword">constexpr</span> <span class="type">int</span> <span class="title">func</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">  <span class="comment">//可以添加 using 执行、typedef 语句以及 static_assert 断言</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">1</span> + <span class="number">2</span> + x;</span><br><span class="line">&#125;<span class="comment">//正确写法</span></span><br></pre></td></tr></table></figure></div>

<p>二、<strong>该函数必须有返回值，并且类型不能是<code>void</code></strong></p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">constexpr</span> <span class="type">void</span> <span class="title">func</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//函数体</span></span><br><span class="line">&#125;<span class="comment">//错误，通过此函数无法获得一个常量</span></span><br></pre></td></tr></table></figure></div>

<p>三、<strong>函数在使用之前，必须有对应的定义语句。</strong><br>对于其他的函数来说，在使用时前给出声明即可，并不需要在给出定义。但是对于常量表达式函数来说，由于其返回值会在编译过程中进行计算，所以使用之前一定需要知道函数具体的定义。</p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">//普通函数的声明</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">noconst_func</span><span class="params">(<span class="type">int</span> x)</span></span>;</span><br><span class="line"><span class="comment">//常量表达式函数的声明</span></span><br><span class="line"><span class="function"><span class="keyword">constexpr</span> <span class="type">int</span> <span class="title">func</span><span class="params">(<span class="type">int</span> x)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//常量表达式函数的定义</span></span><br><span class="line"><span class="function"><span class="keyword">constexpr</span> <span class="type">int</span> <span class="title">func</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span> + <span class="number">2</span> + x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//调用常量表达式函数</span></span><br><span class="line">    <span class="type">int</span> a[<span class="built_in">func</span>(<span class="number">3</span>)] = &#123; <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span> &#125;;</span><br><span class="line">    cout &lt;&lt; a[<span class="number">2</span>] &lt;&lt; endl;</span><br><span class="line">    <span class="comment">//调用普通函数</span></span><br><span class="line">    cout &lt;&lt; <span class="built_in">noconst_func</span>(<span class="number">3</span>) &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//普通函数的定义</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">noconst_func</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span> + <span class="number">2</span> + x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>四、<strong>返回的表达式必须是常量表达式</strong></p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> num = <span class="number">3</span>;</span><br><span class="line"><span class="function"><span class="keyword">constexpr</span> <span class="type">int</span> <span class="title">func</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> num + x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//调用常量表达式函数</span></span><br><span class="line">    <span class="type">int</span> a[<span class="built_in">func</span>(<span class="number">3</span>)] = &#123; <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span> &#125;;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;<span class="comment">//error:func(3) 的结果不是常量</span></span><br></pre></td></tr></table></figure></div>

<p>常量表达式函数的返回值必须是常量表达式的原因很简单，如果想在程序编译阶段获得某个函数返回的常量，则该函数的<code>return</code>语句中就不能包含程序运行阶段才能确定值的变量(上述代码中的<code>num</code>)。</p>
<p><strong>注：在常量表达式函数的<code>return</code>语句中，不能包含赋值的操作（例如 <code>return x=1</code> 在常量表达式函数中不允许的）。另外，用 <code>constexpr</code> 修改函数时，函数本身也是支持递归的。</strong></p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">constexpr</span> <span class="type">int</span> <span class="title">fact</span><span class="params">(<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 递归求阶乘</span></span><br><span class="line">    <span class="keyword">return</span> n == <span class="number">1</span> ? <span class="number">1</span> : n * <span class="built_in">fact</span>(n - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h2 id="3-constexpr修饰类的构造函数"><a href="#3-constexpr修饰类的构造函数" class="headerlink" title="3.constexpr修饰类的构造函数"></a>3.<code>constexpr</code>修饰类的构造函数</h2><p>对于 C++ 内置类型的数据，可以直接用<code>constexpr</code>修饰，但如果是自定义的数据类型（结构体或者类），是不可以直接用<code>constexpr</code>修饰的。</p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">//自定义类型的定义</span></span><br><span class="line"><span class="keyword">constexpr</span> <span class="keyword">struct</span> <span class="title class_">myType</span> &#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>* name;</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">    <span class="comment">//其它结构体成员</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">constexpr</span> <span class="keyword">struct</span> <span class="title class_">myType</span> mt &#123; <span class="string">&quot;zhangsan&quot;</span>, <span class="number">10</span> &#125;;</span><br><span class="line">    cout &lt;&lt; mt.name &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; mt.age &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;<span class="comment">//error:constexpr不能修饰自定义类型</span></span><br></pre></td></tr></table></figure></div>

<p>为了自定义一个可以产生常量的类型，可以在该类型的内部添加一个常量构造函数。将上述错误例程修改如下：</p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">//自定义类型的定义</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">myType</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">constexpr</span> <span class="title">myType</span><span class="params">(<span class="type">char</span> *name,<span class="type">int</span> age)</span>:name(name),age(age)&#123;</span>&#125;;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>* name;</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">    <span class="comment">//其它结构体成员</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">constexpr</span> <span class="keyword">struct</span> <span class="title class_">myType</span> mt &#123; <span class="string">&quot;shiszhi&quot;</span>, <span class="number">20</span> &#125;;</span><br><span class="line">    cout &lt;&lt; mt.name &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; mt.age &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;<span class="comment">//output:shiszhi 20</span></span><br></pre></td></tr></table></figure></div>

<p>注意: <strong><code>constexpr</code>修饰类的构造函数时，要求该构造函数的函数体必须为空，且采用初始化列表的方式为各个成员赋值时，必须使用常量表达式。</strong><br>前面提到，<code>constexpr</code>可用于修饰函数，当然也可以修饰类内的成员函数，只要满足上述四个条件即可。不过需要注意的是，<strong>在C++11标准中，不支持用<code>constexpr</code>修饰带有<code>virtual</code>的成员方法。</strong></p>
<h2 id="4-constexpr修饰模板函数"><a href="#4-constexpr修饰模板函数" class="headerlink" title="4.constexpr修饰模板函数"></a>4.<code>constexpr</code>修饰模板函数</h2><p>C++11语法中，<code>constexpr</code>可以修饰模板函数，但由于模板中类型的不确定性，因此模板函数实例化后的函数是否符合常量表达式函数的要求也是不确定的。<br>针对这种情况，C++11标准规定，如果<code>constexpr</code>修饰的模板函数实例化结果不满足常量表达式函数的要求，则<code>constexpr</code>会被自动忽略，即该函数就等同于一个普通函数。</p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">//自定义类型的定义</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">myType</span> &#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>* name;</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">    <span class="comment">//其它结构体成员</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//模板函数</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">constexpr</span> T <span class="title">display</span><span class="params">(T t)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> t;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">myType</span> stu&#123;<span class="string">&quot;shiszhi&quot;</span>, <span class="number">20</span>&#125;;</span><br><span class="line">    <span class="comment">//普通函数,stu未定义常量表达式构造函数</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">myType</span> ret = <span class="built_in">display</span>(stu);</span><br><span class="line">    cout &lt;&lt; ret.name &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; ret.age &lt;&lt; endl;</span><br><span class="line">    <span class="comment">//常量表达式函数</span></span><br><span class="line">    <span class="keyword">constexpr</span> <span class="type">int</span> ret1 = <span class="built_in">display</span>(<span class="number">20</span>);</span><br><span class="line">    cout &lt;&lt; ret1 &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h2 id="5-总结"><a href="#5-总结" class="headerlink" title="5.总结"></a>5.总结</h2><p>《Effective Modern C++》中提到：只要有可能使用<code>constexpr</code>，就使用它。比起非<code>constexpr</code>对象或者<code>constexpr</code>函数而言，<code>constexpr</code>对象或者<code>constexpr</code>函数可以用在一个作用域更广的语境中。</p>
]]></content>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>FFmpeg之FFmpeg简介</title>
    <url>/2022/12/07/FFmpeg%E4%B9%8BFFmpeg%E7%AE%80%E4%BB%8B/</url>
    <content><![CDATA[<h2 id="1-FFmpeg定义"><a href="#1-FFmpeg定义" class="headerlink" title="1. FFmpeg定义"></a>1. FFmpeg定义</h2><p>FFmpeg是一款音视频编解码工具，同时也是一组音视频编解码开发套件，为开发者提供了丰富的音视频处理的调用接口。<br>FFmpeg提供了多种媒体格式的封装和解封装，包括多种音视频解码、多种协议的流媒体、多种色彩格式转换、多种采样率转换、多种码率转换等；FFmpeg框架提供了多种丰富的插件模块，包含封装与解封装的插件、编码与解码的插件等。</p>
<h2 id="2-FFmpeg的基本组成"><a href="#2-FFmpeg的基本组成" class="headerlink" title="2. FFmpeg的基本组成"></a>2. FFmpeg的基本组成</h2><p>FFmpeg框架的基本组成包含<code>AVFormat</code>、<code>AVCodec</code>、<code>AVFilter</code>、<code>AVDevice</code>、<code>AVUtil</code>等模块，结构图如下：<br><img lazyload src="/images/loading.svg" data-src="/2022/12/07/FFmpeg%E4%B9%8BFFmpeg%E7%AE%80%E4%BB%8B/2-1.png" alt="图2-1 FFmpeg基本组成模块"></p>
<ol>
<li><strong>FFmpeg的封装模块AVFormat</strong><br>AVFormat中实现了目前多媒体领域中的绝大多数媒体封装格式，包括封装和解封装，如MP4、FLV、KV、TS等文件封装格式，RTMP、RTSP、MMS、HLS等网络协议封装格式。<br>FFmpeg是否支持某种媒体封装格式，取决于编译时是否包含了该格式的封装库、根据实际需求可以进行媒体封装格式的扩展，增加自己定制的封装格式。</li>
<li><strong>FFmpeg的编解码模块AVCodec</strong><br>AVCodec中实现了目前多媒体领域绝大多数常用的编解码格式，既支持编码，也支持解码。<br>AVCodec除了支持MPEG4、AAC、MJPEG等自带的媒体编解码格式之外，还支持第三方编解码器。<br>如果希望增加自己的编码格式，或者硬件编解码，则需要在AVCodec中增加相应的编解码模块。</li>
<li><strong>FFmpeg的滤镜模块AVFilter</strong><br>AVFilter库提供了一个通用的音频、视频、字幕等滤镜处理框架。在AVFilter中，滤镜框架可以有多个输入和多个输出。可以参考以下示例：<br><img lazyload src="/images/loading.svg" data-src="/2022/12/07/FFmpeg%E4%B9%8BFFmpeg%E7%AE%80%E4%BB%8B/2-2.png" alt="图2-2 AVFilter使用样例"><br>上图中所示的滤镜处理将输入的视频切割成了两部分流，一部分流抛给crop滤镜与vflip滤镜处理模块进行操作，另一部分保持原样，当crop滤镜与vflip滤镜处理操作完成之后，将流合并到原有的overlay图层中，并显示在最上一层，输出新的视频。对应的命令如下：</li>
</ol>
<div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line">ffmpeg -i INPUT -vf &quot;split [main][tmp]; [tmp] crop=iw:ih/2:0:0, vflip [flip]; [main][flip] overlay=0:H/2&quot; OUTPUT</span><br></pre></td></tr></table></figure></div>

<p>下面详细说明一下规则，具体如下：</p>
<ul>
<li>相同的Filter线性链之间用逗号分隔</li>
<li>不同的Filter线性链之间用分号分隔</li>
</ul>
<p>在上述示例中，crop与vflip使用的是同一个滤镜处理的线性链，split滤镜和overlay滤镜使用的是另外一个线性链，一个线性链与另一个线性链汇合时时通过方括号<code>[]</code>括起来的标签进行标识的。<br>4. <strong>FFmpeg的视频图像转换计算模块swscale</strong><br>swscale模块提供高级别的图像转换API，允许其进行图像缩放和像素格式转换。<br>例如：将图像从1080P转换成720P或者480P等的缩放，或者将图像数据从YUV420P转换成YUYV等的转换。<br>5. <strong>FFmpeg的音频转换计算模块swresample</strong><br>swresample模块提供了高级别的音频重采样API。例如它允许操作音频采样、音频通道布局转换与布局调整。</p>
<h2 id="3-FFmpeg的编解码工具ffmpeg"><a href="#3-FFmpeg的编解码工具ffmpeg" class="headerlink" title="3. FFmpeg的编解码工具ffmpeg"></a>3. <strong>FFmpeg的编解码工具ffmpeg</strong></h2><p>一个简单的例子：</p>
<div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line">ffmpeg -i input.mp4 output.avi</span><br></pre></td></tr></table></figure></div>

<p>这条简单的命令通过<code>-i</code>指定输入源，然后进行转码和转封装，将结果输出到<code>output.avi</code>中，这条命令主要进行以下流程：</p>
<ol>
<li>获得输入源<code>input.mp4</code></li>
<li>转码、转封装</li>
<li>输出文件<code>output.avi</code></li>
</ol>
<p>下面这条命令和上面的命令具有类似的作用：</p>
<div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line">ffmpeg -i input.mp4 -f avi output.dat</span><br></pre></td></tr></table></figure></div>

<p>此命令通过<code>-f</code>选项指定输出文件的容器格式，两条命令输出的文件名不同，除此之外完全相同。</p>
<p>ffmpeg的主要工作流程如下：</p>
<ol>
<li>解封装(Demuxing)</li>
<li>解码(Decoding)</li>
<li>编码(Encoding)</li>
<li>封装(Muxing)</li>
</ol>
<p>其中需要经过六个步骤，分别为：</p>
<ol>
<li>读取输入源</li>
<li>进行音视频的解封装</li>
<li>解码每一帧音视频数据</li>
<li>编码每一帧音视频数据</li>
<li>进行音视频的重新封装</li>
<li>输出到目标</li>
</ol>
<p><img lazyload src="/images/loading.svg" data-src="/2022/12/07/FFmpeg%E4%B9%8BFFmpeg%E7%AE%80%E4%BB%8B/3-1.png" alt="图3-1 ffmpeg转码工作流程"><br>在上图所示的工作流程中可以看出：ffmpeg首先读取输入源，然后通过Demuxer进行解封装（通过调用<code>libavformat</code>中的接口实现），然后通过Decoder进行解码（通过调用<code>libavcodec</code>中的接口实现），然后通过Encoder将对应的数据进行编码（通过调用<code>libavcodec</code>中的接口实现），接下来将编码后的音视频数据包通过Muxer进行封装（通过调用<code>libavformat</code>中的接口实现），输出称为输出流。</p>
<h2 id="4-FFmpeg的播放器ffplay"><a href="#4-FFmpeg的播放器ffplay" class="headerlink" title="4. FFmpeg的播放器ffplay"></a>4. FFmpeg的播放器ffplay</h2><p>ffplay为FFmpeg提供的播放器，使用FFmpeg的<code>avformat</code>与<code>avcodec</code>可以播放各种媒体文件或流。如果要使用ffplay，需要系统有各种SDL(Simple DirectMedia Layer)提供基础支撑。<br>ffmpeg提供了音视频显示和播放相关的图像信息、音频的波形信息等。</p>
<h2 id="5-Ffmpeg的多媒体分析器ffprobe"><a href="#5-Ffmpeg的多媒体分析器ffprobe" class="headerlink" title="5. Ffmpeg的多媒体分析器ffprobe"></a>5. Ffmpeg的多媒体分析器ffprobe</h2><p>ffprobe可以从媒体文件或者媒体流中获得想要了解的媒体信息，比如音频的参数、视频的参数、媒体容器的参数信息等。<br>其可以帮助分析某个媒体容器中的音频是什么编码格式、视频是什么编码格式，同时可以得到媒体文件中媒体的总时长、复合码率等信息。除此之外也可以分析媒体文件中每个包的长度、包的类型、帧的信息等。</p>
<h2 id="6-FFmpeg编码支持与定制"><a href="#6-FFmpeg编码支持与定制" class="headerlink" title="6. FFmpeg编码支持与定制"></a>6. FFmpeg编码支持与定制</h2><h3 id="6-1-FFmpeg的编解码器支持"><a href="#6-1-FFmpeg的编解码器支持" class="headerlink" title="6.1. FFmpeg的编解码器支持"></a>6.1. FFmpeg的编解码器支持</h3><p>编码器支持：</p>
<div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line">ffmpeg -encoders</span><br></pre></td></tr></table></figure></div>

<p>解码器支持：</p>
<div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line">ffmpeg -decoders</span><br></pre></td></tr></table></figure></div>

<h3 id="6-2-FFmpeg的封装及解封装支持"><a href="#6-2-FFmpeg的封装及解封装支持" class="headerlink" title="6.2. FFmpeg的封装及解封装支持"></a>6.2. FFmpeg的封装及解封装支持</h3><p>封装支持</p>
<div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line">ffmpeg -muxers</span><br></pre></td></tr></table></figure></div>

<p>解封装支持</p>
<div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line">ffmpeg -demuxers</span><br></pre></td></tr></table></figure></div>

<h3 id="6-3-FFmpeg的通信协议支持"><a href="#6-3-FFmpeg的通信协议支持" class="headerlink" title="6.3. FFmpeg的通信协议支持"></a>6.3. FFmpeg的通信协议支持</h3><div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line">ffmpeg -protocols</span><br></pre></td></tr></table></figure></div>

<h2 id="7-小结"><a href="#7-小结" class="headerlink" title="7.小结"></a>7.小结</h2><p>本文主要介绍了FFmpeg的一些基础知识，重点在整个音视频处理流程以及对流媒体传输协议的支持。</p>
]]></content>
      <tags>
        <tag>FFmpeg</tag>
      </tags>
  </entry>
  <entry>
    <title>WebRTC基础之RTP/RTCP</title>
    <url>/2022/12/08/WebRTC%E5%9F%BA%E7%A1%80%E4%B9%8BRTP-RTCP/</url>
    <content><![CDATA[<h2 id="1-RTP-Header扩展-Transport-sequence-number"><a href="#1-RTP-Header扩展-Transport-sequence-number" class="headerlink" title="1. RTP Header扩展 - Transport sequence number"></a>1. RTP Header扩展 - Transport sequence number</h2><p>下面是RTP固定报头结构：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line"> 0                   1                   2                   3</span><br><span class="line"> 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1</span><br><span class="line">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">|V=2|P|X|  CC   |M|     PT      |       sequence number         |</span><br><span class="line">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">|                           timestamp                           |</span><br><span class="line">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">|           synchronization source (SSRC) identifier            |</span><br><span class="line">+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+</span><br><span class="line">|            contributing source (CSRC) identifiers             |</span><br><span class="line">|                             ....                              |</span><br><span class="line">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br></pre></td></tr></table></figure></div>

<p>报头中的<code>sequence number</code>字段用于记录RTP包的序列号。一般情况下一个传输通道（PeerConnection）只包含一路视频流，这个<code>sequence number</code>可以满足大多数需求。但某些情况下，一个连接可能传输多个视频流，这些视频流复用一个传输通道。此时一个PeerConnection可能包含多个不同的视频流。在这些视频流中，RTP报头的<code>sequence number</code>是单独计数的。</p>
<p>假设同一个PeerConnection下，我们传输两个视频流A与B，它们的RTP包记为Ra(n)，Rb(n)，n表示<code>sequence number</code>。<br>这样我们观察同一个PeerConnection下，视频流按如下形式传输： Ra(1),Ra(2),Rb(1),Rb(2),Ra(3),Ra(4),Rb(3),Rb(4)</p>
<p>在对某条PeerConnection进行带宽估计时，我们需要估计整条PeerConnection下所有视频流，而不是单独某个流。这样为了做一个RTP session（传输层）级别的带宽估计，原有各个流的<code>sequence number</code>就不能满足我们需要了，需要使用RTP报头扩展用于记录<code>transport sequence number</code>，同一个PeerConnection连接下的所有流的<code>transport sequence number</code>，使用统一的计数器进行计数，方便进行同一个PeerConnection下的带宽估计。</p>
<p>仍使用上面的例子，视频流A与B，它们的RTP包记为Ra(n，m)，Rb(n,m)，n表示<code>sequence number</code>，m表示<code>transport sequence number</code>。<br>这样同一个PeerConnection下，视频流按如下形式传输： Ra(1,1),Ra(2,2),Rb(1,3),Rb(2,4),Ra(3,5),Ra(4,6),Rb(3,7),Rb(4,8)</p>
<p>RTP <code>transport sequence number</code>报头定义如下：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line"> 0                   1                   2                   3</span><br><span class="line"> 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1</span><br><span class="line">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">|       0xBE    |    0xDE       |           length=1            |</span><br><span class="line">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">|  ID   | L=1   |transport-wide sequence number | zero padding  |</span><br><span class="line">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br></pre></td></tr></table></figure></div>

<p>由于属于RTP报头扩展，所以可以看到以<code>0xBEDE</code>固定字段开头，表示One-Byte Header类型的扩展。<code>transport sequence number</code>占两个字节，存储在One-Byte Header的<code>Extension data</code>字段。由于按4字节对齐，所以还有值为0的填充数据。</p>
<h2 id="2-TransportFeedback-RTCP"><a href="#2-TransportFeedback-RTCP" class="headerlink" title="2. TransportFeedback RTCP"></a>2. TransportFeedback RTCP</h2><p>Transport-cc中，收流客户端通过TransportFeedback RTCP向发送端反馈收到的各个RTP包的到达时间信息。<br>下面是TransportFeedback包的格式：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">    0                   1                   2                   3</span><br><span class="line">    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1</span><br><span class="line">   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">   |V=2|P|  FMT=15 |    PT=205     |           length              |</span><br><span class="line">   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line"> 0 |                     SSRC of packet sender                     |</span><br><span class="line">   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line"> 4 |                      SSRC of media source                     |</span><br><span class="line">   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line"> 8 |      base sequence number     |      packet status count      |</span><br><span class="line">   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">12 |                 reference time                | fb pkt. count |</span><br><span class="line">   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">16 |          packet chunk         |         packet chunk          |</span><br><span class="line">   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">   .                                                               .</span><br><span class="line">   .                                                               .</span><br><span class="line">   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">   |         packet chunk          |  recv delta   |  recv delta   |</span><br><span class="line">   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">   .                                                               .</span><br><span class="line">   .                                                               .</span><br><span class="line">   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">   |           recv delta          |  recv delta   | zero padding  |</span><br><span class="line">   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br></pre></td></tr></table></figure></div>

<ul>
<li><code>base sequence number</code>:2字节，TransportFeedback包中记录的第一个RTP包的<code>transport sequence number</code>，在反馈的各个TransportFeedback RTCP包中，这个字段不一定是递增的，也有可能比之前的RTCP包小</li>
<li><code>packet status count</code>:2字节，表示这个TransportFeedback包记录了多少个RTP包信息，这些RTP的<code>transport sequence number</code>以<code>base sequence number</code>为基准，比如记录的第一个RTP包的<code>transport sequence number</code>为<code>base sequence number</code>，那么记录的第二个RTP包<code>transport sequence number</code>为<code>base sequence number+1</code></li>
<li><code>reference time</code>:3字节，表示参考时间，以64ms为单位，RTCP包记录的RTP包到达时间信息以这个<code>reference time</code>为基准进行计算</li>
<li><code>feedback packet count</code>:1字节，用于计数发送的每个TransportFeedback包，相当于RTCP包的序列号。可用于检测TransportFeedback包的丢包情况</li>
<li><code>packet chunk</code>:2字节，记录RTP包的到达状态，记录的这些RTP包<code>transport sequence number</code>通过<code>base sequence number</code>计算得到</li>
<li><code>recv delta</code>: 1字节，对于<code>packet received</code>状态的包，也就是收到的RTP包，在<code>recv delta</code>列表中添加对应的的到达时间间隔信息，用于记录RTP包到达时间信息。通过前面的<code>reference time</code>以及<code>recv delta</code>信息，我们就可以得到RTP包到达时间</li>
</ul>
<h3 id="2-1-Packet-Chunk"><a href="#2-1-Packet-Chunk" class="headerlink" title="2.1 Packet Chunk"></a>2.1 Packet Chunk</h3><p>首先先了解下RTP包状态，目前定义了如下四种状态，每个状态值2bits，用来标识RTP包的到达状态，以及与前面RTP包的时间间隔大小信息：</p>
<ul>
<li>00-Packet not received</li>
<li>01-Packet received, small delta</li>
<li>10-Packet received, large or negative delta</li>
<li>11-[Reserved]<br><code>packet chunk</code>有两种类型，<code>Run length chunk</code>（行程长度编码数据块）与<code>Status vector chunk</code>（状态矢量编码数据块），对应<code>packet chunk</code>结构的两种编码方式。packet chunk的第一个bit标识chunk类型。</li>
</ul>
<h4 id="2-1-1-Run-length-chunk"><a href="#2-1-1-Run-length-chunk" class="headerlink" title="2.1.1 Run length chunk"></a>2.1.1 Run length chunk</h4><p>Run length编码是一种数据压缩算法，其基本思想是将重复且连续出现多次的字符使用“连续出现次数+字符”来描述，例如：aaabbbcdddd通过Run length编码就可以压缩为3a3bc4d。Run length chunk中使用了Run length编码标识连续多个相同状态的包。<br>Run length chunk第一bit为0，后面跟着packet status以及run length。格式如下：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line"> 0                   1</span><br><span class="line"> 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5</span><br><span class="line">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">|T| S |       Run Length        |</span><br><span class="line">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br></pre></td></tr></table></figure></div>

<ul>
<li><code>chunk type (T)</code>:1 bit，值为0</li>
<li><code>packet status symbol (S)</code>:2 bits，标识包状态</li>
<li><code>run length (L)</code>:13 bits，行程长度，标识有多少个连续包为相同状态</li>
</ul>
<p>举例如下：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line"> 0                   1</span><br><span class="line"> 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5</span><br><span class="line">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">|0|0 0|0 0 0 0 0 1 1 0 1 1 1 0 1|</span><br><span class="line">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br></pre></td></tr></table></figure></div>

<p><code>packet status</code>为00，由前面包状态可知为<code>Packet not received</code>状态，<code>run length</code>为221（11011101），说明连续有221个包为<code>Packet not received</code>状态。</p>
<h4 id="2-1-2-Status-Vector-Chunk"><a href="#2-1-2-Status-Vector-Chunk" class="headerlink" title="2.1.2 Status Vector Chunk"></a>2.1.2 Status Vector Chunk</h4><p>第一bit为1，后面跟着symbol size以及symbol list。格式如下：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line"> 0                   1</span><br><span class="line"> 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5</span><br><span class="line">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">|T|S|       symbol list         |</span><br><span class="line">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br></pre></td></tr></table></figure></div>

<ul>
<li><code>chunk type (T)</code>:1 bit，值为1</li>
<li><code>symbol size(S)</code>:1 bit，为0表示只包含<code>packet not received</code>以及<code>packet received</code>状态，每个状态使用1bit表示，这样后面14bits的<code>symbol list</code>能标识14个包的状态。为1表示使用2bits来标识包状态，这样<code>symbol list</code>中我们只能标识7个包的状态</li>
<li><code>symbol list</code>:14 bits，标识一系列包的状态, 总共能标识7或14个包的状态</li>
</ul>
<p>举例如下：</p>
<ol>
<li>例一：</li>
</ol>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line"> 0                   1</span><br><span class="line"> 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5</span><br><span class="line">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">|1|0|0 1 1 1 1 1 0 0 0 1 1 1 0 0|</span><br><span class="line">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br></pre></td></tr></table></figure></div>

<p><code>symbol size</code>为0，这样能标识14个包的状态。第一个包状态为<code>packet not received</code>，接着后面5个包状态为<code>packet received</code>，再接着三个包状态为<code>packet not received</code>，再接着三个包状态为<code>packet received</code>，最后两个包状态为<code>packet not received</code>。<br>2. 例二：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line"> 0                   1</span><br><span class="line"> 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5</span><br><span class="line">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">|1|1|0 0 1 1 0 1 0 1 0 1 0 0 0 0|</span><br><span class="line">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br></pre></td></tr></table></figure></div>

<p><code>symbol size</code>为1，这样只能标识7个包的状态。第一个包为<code>packet not received</code>状态，第二个包为<code>packet received, w/o timestamp</code>状态，再接着三个包为<code>packet received</code>状态，最后两个包为<code>packet not received</code>状态。</p>
<h3 id="2-2-Receive-Delta"><a href="#2-2-Receive-Delta" class="headerlink" title="2.2 Receive Delta"></a>2.2 Receive Delta</h3><p>以250us(0.25ms)为单位，表示RTP包到达时间与前面一个RTP包到达时间的间隔，对于记录的第一个RTP包，该包的时间间隔是相对reference time的。</p>
<ul>
<li>如果在<code>packet chunk</code>记录了一个<code>Packet received, small delta</code>状态的包，那么就会在<code>receive delta</code>列表中添加一个无符号1字节长度<code>receive delta</code>，无符号1字节取值范围[0,255]，由于<code>Receive Delta</code>以0.25ms为单位，故此时<code>Receive Delta</code>取值范围[0, 63.75]ms</li>
<li>如果在<code>packet chunk</code>记录了一个<code>Packet received, large or negative delta</code>状态的包，那么就会在<code>receive delta</code>列表中添加一个有符号2字节长度的<code>receive delta</code>，范围[-8192.0, 8191.75]ms</li>
<li>如果时间间隔超过了最大限制，那么就会构建一个新的TransportFeedback RTCP包，由于<code>reference time</code>长度为3字节，所以目前的包中3字节长度能够覆盖很大范围了<br>以上说明总结起来就是：对于收到的RTP包在TransportFeedback RTCP <code>receive delta</code>列表中通过时间间隔记录到达时间，如果与前面包时间间隔小，那么使用1字节表示，否则2字节，超过最大取值范围，就另起新RTCP包了。<br>对于<code>Packet received, small delta</code>状态的包来说，<code>receive delta</code>最大值63.75ms，那么一秒时间跨度最少能标识1000&#x2F;63.75~&#x3D;16个包。由于<code>receive delta</code>为250us的倍数，所以一秒时间跨度最多能标识4000个包。<br><code>packet chunk</code>以及<code>receive delta</code>的使用是为了尽可能减小RTCP包大小。<code>packet chunk</code>用到了不同编码方式，对于收到的RTP包才添加到达时间信息，而且是通过时间间隔的方式记录到达时间。</li>
</ul>
]]></content>
      <tags>
        <tag>WebRTC基础</tag>
      </tags>
  </entry>
  <entry>
    <title>WebRTC源码分析之任务队列-TaskQueueBase</title>
    <url>/2022/12/06/WebRTC%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E4%B9%8B%E4%BB%BB%E5%8A%A1%E9%98%9F%E5%88%97-TaskQueueBase/</url>
    <content><![CDATA[<h2 id="1-前言"><a href="#1-前言" class="headerlink" title="1. 前言"></a>1. 前言</h2><p>任务队列 <code>TaskQueue</code>是WebRTC中非常核心的一部分，其主要功能是将任务投递到某一个线程执行。<code>TaskQueue</code>是WebRTC中进程交互很重要的方式。<br>本文主要分析 <code>TaskQueue</code>中最重要的基类 <code>TaskQueueBase</code>。<br><code>TaskQueue</code>机制中涉及的其他类后续会继续补充。<br>WebRTC版本：M84</p>
<h2 id="2-正文"><a href="#2-正文" class="headerlink" title="2. 正文"></a>2. 正文</h2><h3 id="2-0-预说明：线程局部存储"><a href="#2-0-预说明：线程局部存储" class="headerlink" title="2.0. 预说明：线程局部存储"></a>2.0. 预说明：线程局部存储</h3><p>任务队列不可避免地涉及到多线程的知识，此处仅简单介绍一下 <code>TaskQueueBase</code>部分涉及到的相关内容以及函数。</p>
<h4 id="2-0-1-线程局部存储概念"><a href="#2-0-1-线程局部存储概念" class="headerlink" title="2.0.1. 线程局部存储概念"></a>2.0.1. 线程局部存储概念</h4><p>线程局部存储（TLS，Thread Local Storage）是线程私有的全局变量。普通的全局变量是多个线程共享的，一个线程对其修改，所有线程均可见。而线程局部存储是线程私有的，每个线程都有自己的一个副本，某个线程对其所做修改只会修改自己的副本，不会影响到其他线程的副本。</p>
<h4 id="2-0-2-pthread-key-t"><a href="#2-0-2-pthread-key-t" class="headerlink" title="2.0.2. pthread_key_t"></a>2.0.2. <code>pthread_key_t</code></h4><div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line">ABSL_CONST_INIT <span class="type">pthread_key_t</span> g_queue_ptr_tls = <span class="number">0</span>;</span><br></pre></td></tr></table></figure></div>

<p>上述声明中 <code>pthread_key_t</code>为前一小节提到的线程局部存储类型</p>
<h4 id="2-0-3-Tls相关函数说明"><a href="#2-0-3-Tls相关函数说明" class="headerlink" title="2.0.3. Tls相关函数说明"></a>2.0.3. <code>Tls</code>相关函数说明</h4><div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">pthread_key_create</span><span class="params">(<span class="type">pthread_key_t</span> *key, <span class="type">void</span> (*destructor)(<span class="type">void</span>*))</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">pthread_setspecific</span><span class="params">(<span class="type">pthread_key_t</span> key, <span class="type">const</span> <span class="type">void</span> *value)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span>* <span class="title">pthread_getspecific</span><span class="params">(<span class="type">pthread_key_t</span> key)</span></span>;</span><br></pre></td></tr></table></figure></div>

<ul>
<li>调用 <code>pthread_key_create</code>函数可以创建 <code>pthread_key_t</code>变量。该函数需要提供两个参数，第一个参数是需要创建的 <code>pthread_key_t</code>变量，第二个参数是一个释放函数，在线程释放其 <code>Tls</code>的时候被调用。如果函数指针被设置成 <code>nullptr</code>，那么系统将调用默认释放函数。该函数成功创建变量时返回0，其他任何返回值均代表出现异常。</li>
<li>当线程中需要存储值的时候，可以调用 <code>pthread_setspcific</code>函数。该函数需要提供两个参数，第一个参数为前面声明的 <code>pthread_key_t</code>变量，第二个为 <code>void*</code>变量，也就意味着可以存储任何类型的值。</li>
<li>如果需要取出所存储的值，调用 <code>pthread_getspecific</code>函数。该函数的参数为前面提到的 <code>pthread_key_t</code>变量，该函数返回 <code>void *</code>类型的值，如需使用，则要进行强制类型转换。</li>
</ul>
<h4 id="2-0-4-InitializeTls"><a href="#2-0-4-InitializeTls" class="headerlink" title="2.0.4. InitializeTls"></a>2.0.4. <code>InitializeTls</code></h4><div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">InitializeTls</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">RTC_CHECK</span>(<span class="built_in">pthread_key_create</span>(&amp;g_queue_ptr_tls, <span class="literal">nullptr</span>)==<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p><code>RTC_CHECK()</code>为WebRTC中的断言宏，当其内部参数为 <code>false</code>时，抛出异常，直接中止当前进程。</p>
<h4 id="2-0-5-GetQueuePtrTls"><a href="#2-0-5-GetQueuePtrTls" class="headerlink" title="2.0.5. GetQueuePtrTls"></a>2.0.5. <code>GetQueuePtrTls</code></h4><div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">pthread_key_t</span> <span class="title">GetQueuePtrTls</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">pthread_once_t</span> init_once = PTHREAD_ONCE_INIT;</span><br><span class="line">    <span class="built_in">RTC_CHECK</span>(<span class="built_in">pthread_once</span>(&amp;init_once, &amp;InitializeTls) == <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> g_queue_ptr_tls; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>调用 <code>pthread_once()</code>函数，传入初值为 <code>PTHREAD_ONCE_INIT</code>的 <code>init_once</code>变量，结合 <code>RTC_CHECK()</code>断言保证 <code>InitializeTls()</code>函数仅执行一次。</p>
<h4 id="2-0-6-说明"><a href="#2-0-6-说明" class="headerlink" title="2.0.6. 说明"></a>2.0.6. 说明</h4><ul>
<li>上述所有函数为全局函数 不属于任何一个对象</li>
<li>上述所有函数只在 <code>WEBRTC_POSIX</code>宏定义的前提下被定义，否则不被定义</li>
<li>定义这些函数是为了供 <code>TaskQueueBase</code>类使用</li>
</ul>
<h3 id="2-1-QueuedTask类"><a href="#2-1-QueuedTask类" class="headerlink" title="2.1. QueuedTask类"></a>2.1. <code>QueuedTask</code>类</h3><blockquote>
<p>Path:<br>api\task_queue\queued_task.h</p>
</blockquote>
<h4 id="2-1-1-类声明"><a href="#2-1-1-类声明" class="headerlink" title="2.1.1. 类声明"></a>2.1.1. 类声明</h4><div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">namespace</span> webrtc&#123;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">QueuedTask</span>&#123;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">QueuedTask</span>() = <span class="keyword">default</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">bool</span> <span class="title">Run</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;<span class="comment">// class QueuedTask</span></span><br><span class="line">&#125; <span class="comment">// namespace webrtc</span></span><br></pre></td></tr></table></figure></div>

<p><code>QueueTask</code>是一个抽象类，为需要异步执行的任务提供基本接口。<br>这个接口由一个单一的函数 <code>Run()</code>组成，它会在目标队列上执行，<code>Run()</code>具体实现的功能由其子类决定。</p>
<h3 id="2-2-TaskQueueBase类"><a href="#2-2-TaskQueueBase类" class="headerlink" title="2.2. TaskQueueBase类"></a>2.2. <code>TaskQueueBase</code>类</h3><blockquote>
<p>Path:<br>api\task_queue\task_queue_base.h<br>api\task_queue\task_queue_base.cc</p>
</blockquote>
<h4 id="2-2-1-类声明"><a href="#2-2-1-类声明" class="headerlink" title="2.2.1. 类声明"></a>2.2.1. 类声明</h4><div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">namespace</span> webrtc&#123;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">RTC_LOCKABLE</span> RTC_EXPORT TaskQueueBase &#123;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Delete</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">PostTask</span><span class="params">(std::unique_ptr&lt;QueuedTask&gt; task)</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">PostDelayedTask</span><span class="params">(std::unique_ptr&lt;QueuedTask&gt; task,</span></span></span><br><span class="line"><span class="params"><span class="function">                                 <span class="type">uint32_t</span> milliseconds)</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="type">static</span> TaskQueueBase* <span class="title">Current</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">IsCurrent</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> Current == <span class="keyword">this</span>; &#125;</span><br><span class="line">  <span class="keyword">protected</span>:</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">CurrentTaskQueueSetter</span>&#123;</span><br><span class="line">      <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="keyword">explicit</span> <span class="title">CurrentTaskQueueSetter</span><span class="params">(TaskQueueBase* task_queue)</span></span>;</span><br><span class="line">        <span class="built_in">CurrentTaskQueueSetter</span>(<span class="type">const</span> CurrentTaskQueueSetter&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">        CurrentTaskQueueSetter&amp; <span class="keyword">operator</span>=(<span class="type">const</span> CurrentTaskQueueSetter&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">        ~<span class="built_in">CurrentTaskQueueSetter</span>();</span><br><span class="line">      <span class="keyword">private</span>:</span><br><span class="line">        TaskQueueBase* <span class="type">const</span> previous_;</span><br><span class="line">    &#125;;<span class="comment">// class CurrentTaskQueueSetter</span></span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">TaskQueueBase</span>() = <span class="keyword">default</span>;</span><br><span class="line">  </span><br><span class="line">&#125;;<span class="comment">// class TaskQueueBase</span></span><br><span class="line">&#125; <span class="comment">// namespace webrtc</span></span><br></pre></td></tr></table></figure></div>

<h4 id="2-2-2-函数实现及相关说明"><a href="#2-2-2-函数实现及相关说明" class="headerlink" title="2.2.2. 函数实现及相关说明"></a>2.2.2. 函数实现及相关说明</h4><h5 id="2-2-2-1-Delete"><a href="#2-2-2-1-Delete" class="headerlink" title="2.2.2.1. Delete"></a>2.2.2.1. <code>Delete</code></h5><div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Delete</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br></pre></td></tr></table></figure></div>

<p>纯虚函数，基类中无需实现。<br>调用此函数开始销毁任务队列，此函数在返回时需要确保没有任务正在运行，也没有新的任务能够在任务队列中启动。<br>同时此函数负责释放对象，释放动作可以在 <code>Delete</code>期间同步进行，也可以在 <code>Delete</code>之后异步进行。<br>销毁某个任务队列对不在此任务队列中的任务不产生任何影响，这些任务也不会因为其他的任务队列销毁而调用任何函数。<br>在任务队列上执行的任务不可以调用 <code>Delete</code>,但是可以调用其他的函数，比如 <code>PostTask</code>。</p>
<h5 id="2-2-2-2-PostTask"><a href="#2-2-2-2-PostTask" class="headerlink" title="2.2.2.2. PostTask"></a>2.2.2.2. <code>PostTask</code></h5><div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">PostTask</span><span class="params">(std::unique_ptr&lt;QueuedTask&gt; task)</span> </span>= <span class="number">0</span>;</span><br></pre></td></tr></table></figure></div>

<p>纯虚函数，基类中无需实现。<br>此函数用于安排一个即时任务的处理，这些任务按照先进先出的顺序执行（所以称为任务队列）。<br>如果 <code>task-&gt;Run()</code>的返回值是 <code>true</code>,代表任务成功执行，任务会在下一个 <code>QueuedTask</code>开始执行之前从任务队列中被移除。</p>
<h5 id="2-2-2-3-PostDelayTask"><a href="#2-2-2-3-PostDelayTask" class="headerlink" title="2.2.2.3. PostDelayTask"></a>2.2.2.3. <code>PostDelayTask</code></h5><div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">PostDelayedTask</span><span class="params">(std::unique_ptr&lt;QueuedTask&gt; task, </span></span></span><br><span class="line"><span class="params"><span class="function">                                           <span class="type">uint32_t</span> milliseconds)</span> </span>= <span class="number">0</span>;</span><br></pre></td></tr></table></figure></div>

<p>纯虚函数，基类中无需实现。<br>此函数用于安排一个延迟任务的处理，处理会在调用 <code>PostDelayedTask</code>函数后的 <code>milliseconds</code>毫秒后执行。<br>关于延迟时间的精度可以称作“尽力而为”，在某些场景下，定时可能会有一些毫秒级的误差。</p>
<h5 id="2-2-2-4-Current和-IsCurrent"><a href="#2-2-2-4-Current和-IsCurrent" class="headerlink" title="2.2.2.4. Current和 IsCurrent"></a>2.2.2.4. <code>Current</code>和 <code>IsCurrent</code></h5><p>需要说明的是，从此处开始，相关的的定义会根据所定义的宏而不同，代码块中会给出相关说明。<br>变量及函数声明：</p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> TaskQueueBase* <span class="title">Current</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">IsCurrent</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> <span class="built_in">Current</span>() == <span class="keyword">this</span>; &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//if defined ABSL_HAVE_THREAD_LOCAL</span></span><br><span class="line">ABSL_CONST_INIT <span class="keyword">thread_local</span> TaskQueueBase* current = <span class="literal">nullptr</span>;</span><br></pre></td></tr></table></figure></div>

<p><code>Current()</code>函数定义：</p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// defined ABSL_HAVE_THREAD_LOCAL</span></span><br><span class="line"><span class="function">TaskQueueBase* <span class="title">TaskQueueBase::Current</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> current;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// defined WEBRTC_POSIX</span></span><br><span class="line"><span class="function">TaskQueueBase* <span class="title">TaskQueueBase::Current</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">static_cast</span>&lt;TaskQueueBase*&gt;(<span class="built_in">pthread_getspecific</span>(<span class="built_in">GetQueuePtrTls</span>()));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p><code>Current()</code>函数返回当前线程保存的任务队列，返回值为一个 <code>static</code>变量。<br><code>IsCurrent()</code>函数则用于判断当前线程保存的任务队列是不是对象本身。</p>
<h4 id="2-2-3-说明"><a href="#2-2-3-说明" class="headerlink" title="2.2.3. 说明"></a>2.2.3. 说明</h4><ul>
<li><code>TaskQueueBase</code>是抽象基类，只用于提供接口，不可以被实例化</li>
<li>基于上一条说明，<code>TaskQueueBase</code>的析构函数被声明为虚函数</li>
<li>考虑到文章结构，<code>TaskQueueBase</code>的成员类会在下一节介绍</li>
</ul>
<h3 id="2-3-TaskQueue-CurrentTaskQueueSetter类"><a href="#2-3-TaskQueue-CurrentTaskQueueSetter类" class="headerlink" title="2.3. TaskQueue::CurrentTaskQueueSetter类"></a>2.3. <code>TaskQueue::CurrentTaskQueueSetter</code>类</h3><blockquote>
<p>Path:<br>api\task_queue\task_queue_base.h<br>api\task_queue\task_queue_base.cc</p>
</blockquote>
<h4 id="2-3-1-类声明"><a href="#2-3-1-类声明" class="headerlink" title="2.3.1. 类声明"></a>2.3.1. 类声明</h4><div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">namespace</span> webrtc &#123;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">RTC_LOCKABLE</span> RTC_EXPORT TaskQueueBase &#123;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">  <span class="keyword">class</span> <span class="title class_">RTC_EXPORT</span> CurrentTaskQueueSetter &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">CurrentTaskQueueSetter</span><span class="params">(TaskQueueBase* task_queue)</span></span>;</span><br><span class="line">    <span class="built_in">CurrentTaskQueueSetter</span>(<span class="type">const</span> CurrentTaskQueueSetter&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">    CurrentTaskQueueSetter&amp; <span class="keyword">operator</span>=(<span class="type">const</span> CurrentTaskQueueSetter&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">    ~<span class="built_in">CurrentTaskQueueSetter</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">    TaskQueueBase* <span class="type">const</span> previous_;</span><br><span class="line">  &#125;;<span class="comment">// class CurrentTaskQueueSetter</span></span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;;<span class="comment">// class TaskQueueBase</span></span><br><span class="line">&#125;<span class="comment">// namespace webrtc</span></span><br></pre></td></tr></table></figure></div>

<h4 id="2-3-2-函数实现及相关说明"><a href="#2-3-2-函数实现及相关说明" class="headerlink" title="2.3.2.函数实现及相关说明"></a>2.3.2.函数实现及相关说明</h4><h5 id="2-3-2-1-CurrentTaskQueueSetter"><a href="#2-3-2-1-CurrentTaskQueueSetter" class="headerlink" title="2.3.2.1. CurrentTaskQueueSetter"></a>2.3.2.1. <code>CurrentTaskQueueSetter</code></h5><div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// defined ABSL_HAVE_THREAD_LOCAL</span></span><br><span class="line">TaskQueueBase::CurrentTaskQueueSetter::<span class="built_in">CurrentTaskQueueSetter</span>(</span><br><span class="line">    TaskQueueBase* task_queue)</span><br><span class="line">    : <span class="built_in">previous_</span>(current) &#123;</span><br><span class="line">  current = task_queue;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// defined WEBRTC_POSIX</span></span><br><span class="line">TaskQueueBase::CurrentTaskQueueSetter::<span class="built_in">CurrentTaskQueueSetter</span>(</span><br><span class="line">    TaskQueueBase* task_queue)</span><br><span class="line">    : <span class="built_in">previous_</span>(TaskQueueBase::<span class="built_in">Current</span>()) &#123;</span><br><span class="line">  <span class="built_in">pthread_setspecific</span>(<span class="built_in">GetQueuePtrTls</span>(), task_queue);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>构造函数主要的任务分为两部分：</p>
<ul>
<li>使用 <code>previous_</code>暂存当前线程的任务队列</li>
<li>将 <code>task_queue</code>存放在当前线程的 <code>Tls</code>中</li>
</ul>
<h5 id="2-3-2-2-CurrentTaskQueueSetter"><a href="#2-3-2-2-CurrentTaskQueueSetter" class="headerlink" title="2.3.2.2. ~CurrentTaskQueueSetter"></a>2.3.2.2. <code>~CurrentTaskQueueSetter</code></h5><div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// defined ABSL_HAVE_THREAD_LOCAL</span></span><br><span class="line">TaskQueueBase::CurrentTaskQueueSetter::~<span class="built_in">CurrentTaskQueueSetter</span>() &#123;</span><br><span class="line">  current = previous_;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// defined WEBRTC_POSIX</span></span><br><span class="line">TaskQueueBase::CurrentTaskQueueSetter::~<span class="built_in">CurrentTaskQueueSetter</span>() &#123;</span><br><span class="line">  <span class="built_in">pthread_setspecific</span>(<span class="built_in">GetQueuePtrTls</span>(), previous_);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>构造函数的任务就是将之前暂存在 <code>previous_</code>的任务队列取出，重新放回到当前线程的 <code>Tls</code>当中。</p>
<h4 id="2-3-3-说明"><a href="#2-3-3-说明" class="headerlink" title="2.3.3.说明"></a>2.3.3.说明</h4><p><code>CurrentTaskQueueSetter</code>类只在构造和析构时执行任务：</p>
<ul>
<li>构造时，用传入构造函数的任务队列更新当前线程存放的任务队列，并将更新前的任务队列暂存</li>
<li>析构时，用构造时暂存的任务队列更新当前线程存放的任务队列</li>
</ul>
<h2 id="3-总结"><a href="#3-总结" class="headerlink" title="3. 总结"></a>3. 总结</h2><p><code>TaskQueueBase</code>类作为任务队列机制的核心基类，在后续分析中经常会涉及到，了解其实现方法有助于了解整个任务队列的运行机制。<br>关于任务队列的其他类，后续会在其他文章中进行分析。</p>
]]></content>
      <tags>
        <tag>WebRTC源码分析</tag>
      </tags>
  </entry>
  <entry>
    <title>WebRTC源码分析之任务队列-TaskQueueStdlib</title>
    <url>/2022/12/06/WebRTC%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E4%B9%8B%E4%BB%BB%E5%8A%A1%E9%98%9F%E5%88%97-TaskQueueStdlib/</url>
    <content><![CDATA[<h2 id="1-前言"><a href="#1-前言" class="headerlink" title="1. 前言"></a>1. 前言</h2><p><code>TaskQueueStdlib</code>类是WebRTC任务队列机制的核心类，也是整个任务队列的标准库，在阅读本文之前，需要对 <code>TaskQueueBase</code>类有一定了解。<br>可以参考这篇文章<a href="https://shis-zhi.github.io/2022/12/06/WebRTC%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E4%B9%8B%E4%BB%BB%E5%8A%A1%E9%98%9F%E5%88%97-TaskQueueBase/">WebRTC源码分析-TaskQueue（任务队列）-TaskQueueBase</a><br>WebRTC版本：M84</p>
<h2 id="2-正文"><a href="#2-正文" class="headerlink" title="2. 正文"></a>2. 正文</h2><h3 id="2-0-预说明：TaskQueuePriorityToThreadPriority"><a href="#2-0-预说明：TaskQueuePriorityToThreadPriority" class="headerlink" title="2.0. 预说明：TaskQueuePriorityToThreadPriority"></a>2.0. 预说明：<code>TaskQueuePriorityToThreadPriority</code></h3><div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">rtc::ThreadPriority <span class="title">TaskQueuePriorityToThreadPriority</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    TaskQueueFactory::Priority priority)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">switch</span> (priority) &#123;</span><br><span class="line">    <span class="keyword">case</span> TaskQueueFactory::Priority::HIGH:</span><br><span class="line">      <span class="keyword">return</span> rtc::kRealtimePriority;</span><br><span class="line">    <span class="keyword">case</span> TaskQueueFactory::Priority::LOW:</span><br><span class="line">      <span class="keyword">return</span> rtc::kLowPriority;</span><br><span class="line">    <span class="keyword">case</span> TaskQueueFactory::Priority::NORMAL:</span><br><span class="line">      <span class="keyword">return</span> rtc::kNormalPriority;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      <span class="built_in">RTC_NOTREACHED</span>();</span><br><span class="line">      <span class="keyword">return</span> rtc::kNormalPriority;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>此函数用于将任务队列的优先级转换为线程的优先级。<br><code>TaskQueueFactory::Priority</code>定义如下：</p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">enum class</span> <span class="title class_">Priority</span> &#123; NORMAL = <span class="number">0</span>, HIGH, LOW &#125;;</span><br></pre></td></tr></table></figure></div>

<h3 id="2-1-TaskQueueStdlib类"><a href="#2-1-TaskQueueStdlib类" class="headerlink" title="2.1. TaskQueueStdlib类"></a>2.1. <code>TaskQueueStdlib</code>类</h3><blockquote>
<p>path:<br>rtc_base\task_queue_stdlib.h<br>rtc_base\task_queue_stdlib.cc</p>
</blockquote>
<h4 id="2-1-1-类声明"><a href="#2-1-1-类声明" class="headerlink" title="2.1.1. 类声明"></a>2.1.1. 类声明</h4><div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">TaskQueueStdlib</span> <span class="keyword">final</span> : <span class="keyword">public</span> TaskQueueBase &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">TaskQueueStdlib</span>(absl::string_view queue_name, rtc::ThreadPriority priority);</span><br><span class="line">  ~<span class="built_in">TaskQueueStdlib</span>() <span class="keyword">override</span> = <span class="keyword">default</span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">Delete</span><span class="params">()</span> <span class="keyword">override</span></span>;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">PostTask</span><span class="params">(std::unique_ptr&lt;QueuedTask&gt; task)</span> <span class="keyword">override</span></span>;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">PostDelayedTask</span><span class="params">(std::unique_ptr&lt;QueuedTask&gt; task,</span></span></span><br><span class="line"><span class="params"><span class="function">                       <span class="type">uint32_t</span> milliseconds)</span> <span class="keyword">override</span></span>;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  <span class="keyword">using</span> OrderId = <span class="type">uint64_t</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">DelayedEntryTimeout</span> &#123;</span><br><span class="line">    <span class="type">int64_t</span> next_fire_at_ms_&#123;&#125;;</span><br><span class="line">    OrderId order_&#123;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span>&lt;(<span class="type">const</span> DelayedEntryTimeout&amp; o) <span class="type">const</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> std::<span class="built_in">tie</span>(next_fire_at_ms_, order_) &lt;</span><br><span class="line">             std::<span class="built_in">tie</span>(o.next_fire_at_ms_, o.order_);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">NextTask</span> &#123;</span><br><span class="line">    <span class="type">bool</span> final_task_&#123;<span class="literal">false</span>&#125;;</span><br><span class="line">    std::unique_ptr&lt;QueuedTask&gt; run_task_;</span><br><span class="line">    <span class="type">int64_t</span> sleep_time_ms_&#123;&#125;;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="function">NextTask <span class="title">GetNextTask</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">ThreadMain</span><span class="params">(<span class="type">void</span>* context)</span></span>;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">ProcessTasks</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">NotifyWake</span><span class="params">()</span></span>;</span><br><span class="line">  rtc::Event started_;</span><br><span class="line">  rtc::Event stopped_;</span><br><span class="line">  rtc::Event flag_notify_;</span><br><span class="line">  rtc::PlatformThread thread_;</span><br><span class="line">  rtc::CriticalSection pending_lock_;</span><br><span class="line">  <span class="function"><span class="type">bool</span> thread_should_quit_ <span class="title">RTC_GUARDED_BY</span><span class="params">(pending_lock_)</span></span>&#123;<span class="literal">false</span>&#125;;</span><br><span class="line">  <span class="function">OrderId thread_posting_order_ <span class="title">RTC_GUARDED_BY</span><span class="params">(pending_lock_)</span></span>&#123;&#125;;</span><br><span class="line">  std::queue&lt;std::pair&lt;OrderId, std::unique_ptr&lt;QueuedTask&gt;&gt;&gt; <span class="function">pending_queue_</span></span><br><span class="line"><span class="function">      <span class="title">RTC_GUARDED_BY</span><span class="params">(pending_lock_)</span></span>;</span><br><span class="line">  std::map&lt;DelayedEntryTimeout, std::unique_ptr&lt;QueuedTask&gt;&gt; <span class="function">delayed_queue_</span></span><br><span class="line"><span class="function">      <span class="title">RTC_GUARDED_BY</span><span class="params">(pending_lock_)</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div>

<p>可以看出 <code>TaskQueueStdlib</code>的 <code>public</code>成员除构造函数和析构函数之外只有三个函数，<code>private</code>成员都是为了实现 <code>public</code>方法而定义的，所以后续会先分析其私有成员，最后再分析三个 <code>public</code>成员函数的具体实现方式。</p>
<h4 id="2-1-2-私有成员实现"><a href="#2-1-2-私有成员实现" class="headerlink" title="2.1.2. 私有成员实现"></a>2.1.2. 私有成员实现</h4><p>此处使用 <code>using</code>语句，类似于 <code>typedef</code>，类型 <code>OrderId</code>实际上就是 <code>uint64_t</code>。</p>
<h5 id="2-1-2-1-私有数据成员"><a href="#2-1-2-1-私有数据成员" class="headerlink" title="2.1.2.1. 私有数据成员"></a>2.1.2.1. 私有数据成员</h5><div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 表示该线程是否已经开始</span></span><br><span class="line">rtc::Event started_;</span><br><span class="line"><span class="comment">// 表示该线程是否已经结束</span></span><br><span class="line">rtc::Event stopped_;</span><br><span class="line"><span class="comment">// 每当有新的任务等待时，就会发出信号</span></span><br><span class="line">rtc::Event flag_notify_;</span><br><span class="line"><span class="comment">// 表示被分配用于处理任务的活动工作线程</span></span><br><span class="line">rtc::PlatformThread thread_;</span><br><span class="line"><span class="comment">// 对于存在多个线程访问的数据需要上锁</span></span><br><span class="line">rtc::CriticalSection pending_lock_;</span><br><span class="line"><span class="comment">// 表示工作线程是否需要现在关闭</span></span><br><span class="line"><span class="function"><span class="type">bool</span> thread_should_quit_ <span class="title">RTC_GUARDED_BY</span><span class="params">(pending_lock_)</span></span>&#123;<span class="literal">false</span>&#125;;</span><br><span class="line"><span class="comment">// 保存下一个任务的序号，用于将其放入一个挂起的队列中</span></span><br><span class="line"><span class="function">OrderId thread_posting_order_ <span class="title">RTC_GUARDED_BY</span><span class="params">(pending_lock_)</span></span>&#123;&#125;;</span><br><span class="line"><span class="comment">// 需要在工作线程中按照先进先出的队列顺序处理的待办任务列表</span></span><br><span class="line">std::queue&lt;std::pair&lt;OrderId, std::unique_ptr&lt;QueuedTask&gt;&gt;&gt; <span class="function">pending_queue_</span></span><br><span class="line"><span class="function">    <span class="title">RTC_GUARDED_BY</span><span class="params">(pending_lock_)</span></span>;</span><br><span class="line"><span class="comment">// 需要在工作线程中延迟一段时间再处理的待办任务列表，如果两个任务在相同的时间间隔内</span></span><br><span class="line"><span class="comment">// 发生，那么将根据先后顺序进行处理。</span></span><br><span class="line">std::map&lt;DelayedEntryTimeout, std::unique_ptr&lt;QueuedTask&gt;&gt; <span class="function">delayed_queue_</span></span><br><span class="line"><span class="function">    <span class="title">RTC_GUARDED_BY</span><span class="params">(pending_lock_)</span></span>;</span><br></pre></td></tr></table></figure></div>

<h5 id="2-1-2-2-私有成员类-amp-结构"><a href="#2-1-2-2-私有成员类-amp-结构" class="headerlink" title="2.1.2.2. 私有成员类&amp;结构"></a>2.1.2.2. 私有成员类&amp;结构</h5><div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">DelayedEntryTimeout</span> &#123;</span><br><span class="line">  <span class="type">int64_t</span> next_fire_at_ms_&#123;&#125;;</span><br><span class="line">  OederId order_&#123;&#125;;</span><br><span class="line">  </span><br><span class="line">  <span class="type">bool</span> <span class="keyword">operator</span>&lt;(<span class="type">const</span> DelayedEntryTimeout&amp; o) <span class="type">const</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> std::<span class="built_in">tie</span>(next_fire_at_ms_, order_) &lt; </span><br><span class="line">           std::<span class="built_in">tie</span>(o.next_fire_at_ms_, o.order_);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div>

<p><code>DelayedEntryTimeout</code>具有类似于时间戳的功能，<code>next_fire_at_ms_</code>记录了任务执行的绝对时间，<code>OrderId</code>则记录了任务对应的序号，重载了 <code>&lt;</code>操作符用于比较两个<br><code>DelayedEntryTimeout</code>,该属性较小的任务会先被执行。<br><code>DelayedEntryTimeout</code>比较规则：先比较 <code>next_fire_at_ms_</code>，如果不等直接返回对应的 <code>bool</code>值；如果相等，则再次比较 <code>order</code>,返回比较结果对应的 <code>bool</code>值。</p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">NextTask</span> &#123;</span><br><span class="line">  <span class="type">bool</span> final_task_&#123;<span class="literal">false</span>&#125;;</span><br><span class="line">  std::unique_ptr&lt;QueuedTask&gt; run_task_;</span><br><span class="line">  <span class="type">int64_t</span> sleep_time_ms_&#123;&#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div>

<p><code>NextTask</code>用于表示下一个任务，前两个属性很容易理解，第三个属性是为了兼容 <code>DelayedTask</code>而设置的，具体的实现将会在 <code>GetNextTask</code>函数中介绍到。</p>
<h5 id="2-1-2-3-私有成员函数实现"><a href="#2-1-2-3-私有成员函数实现" class="headerlink" title="2.1.2.3. 私有成员函数实现"></a>2.1.2.3. 私有成员函数实现</h5><h6 id="2-1-2-3-1-GetNextTask"><a href="#2-1-2-3-1-GetNextTask" class="headerlink" title="2.1.2.3.1. GetNextTask"></a>2.1.2.3.1. <code>GetNextTask</code></h6><div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">TaskQueu1Stdlib::NextTask <span class="title">TaskQueueStdlib::GetNextTask</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  NextTask result&#123;&#125;;</span><br><span class="line">  <span class="comment">// 获取当前的绝对时间(ms)</span></span><br><span class="line">  <span class="keyword">auto</span> tick = rtc::<span class="built_in">TimeMillis</span>();</span><br><span class="line"></span><br><span class="line">  <span class="function">rtc::CritScope <span class="title">lock</span><span class="params">(&amp;pending_lock_)</span></span>;</span><br><span class="line">  <span class="comment">// 判断是否线程需要退出</span></span><br><span class="line">  <span class="keyword">if</span> (thread_should_quit_) &#123;</span><br><span class="line">    result.final_task_ = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 如果延迟任务队列非空，则首先从其中取出任务 </span></span><br><span class="line">  <span class="keyword">if</span> (delayed_queue_.<span class="built_in">size</span>() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">// 获取延迟任务相关信息</span></span><br><span class="line">    <span class="keyword">auto</span> delayed_entry = delayed_queue_.<span class="built_in">begin</span>();</span><br><span class="line">    <span class="type">const</span> <span class="keyword">auto</span>&amp; delay_info = delayed_entry-&gt;first;</span><br><span class="line">    <span class="keyword">auto</span>&amp; delay_run = delayed_entry-&gt;second;</span><br><span class="line">    <span class="comment">// 判断是否应该执行延迟任务</span></span><br><span class="line">    <span class="keyword">if</span> (tick &gt;= delay_info.next_fire_at_ms_) &#123;</span><br><span class="line">      <span class="comment">// 如果即时任务队列非空，通过比较决定取出哪种任务</span></span><br><span class="line">      <span class="keyword">if</span> (pending_queue_.<span class="built_in">size</span>() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">auto</span>&amp; entry = pending_queue_.<span class="built_in">front</span>();</span><br><span class="line">        <span class="keyword">auto</span>&amp; entry_order = entry.first;</span><br><span class="line">        <span class="keyword">auto</span>&amp; entry_run = entry.second;</span><br><span class="line">        <span class="comment">// 如果即时任务序号较小，则直接返回该即时任务 </span></span><br><span class="line">        <span class="keyword">if</span> (entry_order &lt; delay_info.order_) &#123;  </span><br><span class="line">          result.run_task_ = std::<span class="built_in">move</span>(entry_run);              <span class="comment">//&lt;--1</span></span><br><span class="line">          pending_queue_.<span class="built_in">pop</span>();</span><br><span class="line">          <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 如果即时任务队列为空，或者1处即时任务序号较大，则取出最靠前的延迟任务</span></span><br><span class="line">      result.run_task_ = std::<span class="built_in">move</span>(delay_run);                  <span class="comment">//&lt;--2</span></span><br><span class="line">      delayed_queue_.<span class="built_in">erase</span>(delayed_entry);</span><br><span class="line">      <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ！！如果运行到这里，此时result.task_run_为nullptr，表明没有任务需要处理</span></span><br><span class="line">    <span class="comment">// 更新sleep_time_ms_</span></span><br><span class="line">    result.sleep_time_ms_ = delay_info.next_fire_at_ms_ - tick; <span class="comment">//&lt;--3</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 延迟任务队列为空，即时任务队列非空</span></span><br><span class="line">  <span class="keyword">if</span> (pending_queue_.<span class="built_in">size</span>() &gt; <span class="number">0</span>) &#123;   </span><br><span class="line">    <span class="keyword">auto</span>&amp; entry = pending_queue_.<span class="built_in">front</span>();                       <span class="comment">//&lt;--4</span></span><br><span class="line">    result.run_task_ = std::<span class="built_in">move</span>(entry.second);</span><br><span class="line">    pending_queue_.<span class="built_in">pop</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>其中涉及到 <code>map</code>和 <code>queue</code>两个容器的相关函数，可以自行查阅。<br>由于 <code>NextTask</code>结构体内部的 <code>run_task_</code>为 <code>unique_ptr</code>，所以不能直接赋值而是使用 <code>std::move</code>转移所有权。</p>
<p><code>GetNextTask</code>函数体较长，逻辑略显复杂，而且非常重要，一定要理清楚如何从任务队列中取出任务。<br>代码块里做了四处标记，便于理解整个流程（此处分析认为 <code>thread_should_quit_</code>为 <code>true</code>）：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">if 延迟任务队列非空</span><br><span class="line">  if 需要执行下一个延迟任务</span><br><span class="line">    if 即时任务队列非空</span><br><span class="line">      if 即时任务序号较小</span><br><span class="line">        返回即时任务(1)</span><br><span class="line">      else </span><br><span class="line">        返回延迟任务(2)</span><br><span class="line">    else</span><br><span class="line">      返回延迟任务(2)</span><br><span class="line">  else</span><br><span class="line">    更新result.sleep_time_ms_(3)</span><br><span class="line">if 即时任务队列非空</span><br><span class="line">  result.run_task_设置为即时任务(4)</span><br><span class="line">返回result</span><br></pre></td></tr></table></figure></div>

<p>这一部分可以概括为：</p>
<ul>
<li><code>result.run_task_</code>为空，<code>result.sleep_time_ms_</code>为0时：两个任务队列均为空</li>
<li><code>result.run_task_</code>为空，<code>result.sleep_time_ms_</code>不为0时：即时任务队列为空，延迟任务队列非空，但是没有可执行的延迟任务</li>
<li><code>result.run_task_</code>不为空，<code>result.sleep_time_ms_</code>为0时：即时任务队列非空，延迟任务队列为空</li>
<li><code>result.run_task_</code>不为空，<code>result.sleep_time_ms_</code>不为0时：即时任务队列非空，延迟任务队列非空，但是没有可执行的延迟任务</li>
</ul>
<h6 id="2-1-2-3-2-ThreadMain"><a href="#2-1-2-3-2-ThreadMain" class="headerlink" title="2.1.2.3.2 ThreadMain"></a>2.1.2.3.2 <code>ThreadMain</code></h6><div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// static</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">TaskQueueStdlib::ThreadMain</span><span class="params">(<span class="type">void</span>* context)</span> </span>&#123;</span><br><span class="line">  TaskQueueStdlib* me = <span class="built_in">static_cast</span>&lt;TaskQueueStdlib*&gt;(context);</span><br><span class="line">  <span class="function">CurrentTaskQueueSetter <span class="title">set_current</span><span class="params">(me)</span></span>;</span><br><span class="line">  me-&gt;<span class="built_in">ProcessTasks</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p><code>ThreadMain</code>是任务处理线程真正的入口函数，其首先将传入的参数强制转换成 <code>TaskQueueStdlib*</code>,然后将这个任务队列注册到当前的线程中，随后开始处理任务。<br>注意此函数是一个 <code>static</code>函数。</p>
<h6 id="2-1-2-3-3-ProcessTasks"><a href="#2-1-2-3-3-ProcessTasks" class="headerlink" title="2.1.2.3.3. ProcessTasks"></a>2.1.2.3.3. <code>ProcessTasks</code></h6><div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">TaskQueueStdlib::ProcessTasks</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  started_.<span class="built_in">Set</span>();</span><br><span class="line">  <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="keyword">auto</span> task = <span class="built_in">GetNextTask</span>();</span><br><span class="line">    <span class="keyword">if</span> (task.final_task_)</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">if</span> (task.run_task_) &#123;</span><br><span class="line">      <span class="comment">// release()会解除智能指针对这个QueuedTask的占用，</span></span><br><span class="line">      <span class="comment">// 并将该智能指针置空</span></span><br><span class="line">      QueuedTask* release_ptr = task.run_task_.<span class="built_in">release</span>();</span><br><span class="line">      <span class="keyword">if</span> (release_ptr-&gt;<span class="built_in">Run</span>())</span><br><span class="line">        <span class="keyword">delete</span> release_ptr;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 取出下一个任务</span></span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// task.sleep_time_ms_为0时表示</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="number">0</span> == task.sleep_time_ms_)</span><br><span class="line">      flag_notify_.<span class="built_in">Wait</span>(rtc::Event::kForever);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      flag_notify_.<span class="built_in">Wait</span>(task.sleep_time_ms_);</span><br><span class="line">  &#125;</span><br><span class="line">  stopped_.<span class="built_in">Set</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p><code>ProcessTasks</code>函数与 <code>GetNextTask</code>函数协同工作。由 <code>GetNextTask</code>函数部分的分析可知只要 <code>task.run_task_</code>为空，就说明即时任务队列为空且暂时没有需要执行的任务，但此时又面临着两种情况：</p>
<ul>
<li>如果延迟任务队列为空，那么直接睡眠直到被唤起</li>
<li>如果延迟任务队列非空，那么将会睡眠指定时间</li>
</ul>
<h6 id="2-1-2-3-4-NotifyWake"><a href="#2-1-2-3-4-NotifyWake" class="headerlink" title="2.1.2.3.4. NotifyWake"></a>2.1.2.3.4. <code>NotifyWake</code></h6><div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">TaskQueueStdlib::NotifyWake</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  flag_notify_.<span class="built_in">Set</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>任务队列中存放着待执行的任务：</p>
<ul>
<li>对于即时任务，线程会忙于执行该任务而不会等待 <code>flag_notify_</code>事件。</li>
<li>如果没有即时任务，但有一个延迟任务正在等待，那么线程将会等待 <code>flag_notify_</code>事件，也就是 <code>ProcessTasks</code>中所提及到的 <code>flag_notify_.Wait(task.sleep_time_ms_);</code></li>
<li>如果即时任务队列和延迟任务队列都为空，那么线程将无限期等待 <code>flag_notify_</code>事件，直到有一个信号显示有新的任务被添加（或者告诉线程需要终止）。</li>
</ul>
<p>任何情况下，当一个新的上述请求被添加后，会发出 <code>flag_notify_</code>信号。如果此时线程正在等待，则会被立即唤醒并且重新评估下一步需要做什么。如果线程并没有在等待，那么线程将保持信号，在下一次试图等待 <code>flag_notify_</code>事件发生时被唤醒。</p>
<p>在发出 <code>flag_notify_</code>信号来唤醒可能正在睡眠的线程之前，需要确保有任务或相关请求添加到队列中，从而避免竞争情况：线程被通知唤醒但是发现没有任务需要执行，所以会再次等待信号，然而这样的信号将有可能不会再次出现。</p>
<h4 id="2-1-3-公有成员实现"><a href="#2-1-3-公有成员实现" class="headerlink" title="2.1.3. 公有成员实现"></a>2.1.3. 公有成员实现</h4><h5 id="2-1-3-1-公有成员函数实现"><a href="#2-1-3-1-公有成员函数实现" class="headerlink" title="2.1.3.1. 公有成员函数实现"></a>2.1.3.1. 公有成员函数实现</h5><h6 id="2-1-3-1-1-TaskQueueStdlib"><a href="#2-1-3-1-1-TaskQueueStdlib" class="headerlink" title="2.1.3.1.1. TaskQueueStdlib"></a>2.1.3.1.1. <code>TaskQueueStdlib</code></h6><div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line">TaskQueueStdlib::<span class="built_in">TaskQueueStdlib</span>(absl::string_view queue_name,</span><br><span class="line">                                 rtc::ThreadPriority priority)</span><br><span class="line">    : <span class="built_in">started_</span>(<span class="comment">/*manual_reset=*/</span><span class="literal">false</span>, <span class="comment">/*initially_signaled=*/</span><span class="literal">false</span>),</span><br><span class="line">      <span class="built_in">stopped_</span>(<span class="comment">/*manual_reset=*/</span><span class="literal">false</span>, <span class="comment">/*initially_signaled=*/</span><span class="literal">false</span>),</span><br><span class="line">      <span class="built_in">flag_notify_</span>(<span class="comment">/*manual_reset=*/</span><span class="literal">false</span>, <span class="comment">/*initially_signaled=*/</span><span class="literal">false</span>),</span><br><span class="line">      <span class="built_in">thread_</span>(&amp;TaskQueueStdlib::ThreadMain, <span class="keyword">this</span>, queue_name, priority) &#123;</span><br><span class="line">  thread_.<span class="built_in">Start</span>();</span><br><span class="line">  started_.<span class="built_in">Wait</span>(rtc::Event::kForever);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>创建一个任务处理线程，随后开始执行入口函数并挂起当前线程。<br>当任务处理线程准备就绪之后，会唤醒当前线程。<br>当前线程负责创建一个任务处理线程并且向其投递任务，任务处理线程负责处理任务队列内的任务。</p>
<h6 id="2-1-3-1-2-Delete"><a href="#2-1-3-1-2-Delete" class="headerlink" title="2.1.3.1.2.Delete"></a>2.1.3.1.2.<code>Delete</code></h6><div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">TaskQueueStdlib::Delete</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">RTC_DCHECK</span>(!<span class="built_in">IsCurrent</span>());</span><br><span class="line"></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="function">rtc::CritScope <span class="title">lock</span><span class="params">(&amp;pending_lock_)</span></span>;</span><br><span class="line">    thread_should_quit_ = <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">NotifyWake</span>();</span><br><span class="line"></span><br><span class="line">  stopped_.<span class="built_in">Wait</span>(rtc::Event::kForever);</span><br><span class="line">  thread_.<span class="built_in">Stop</span>();</span><br><span class="line">  <span class="keyword">delete</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>此函数用于销毁任务队列对象：</p>
<ul>
<li>首先判断当前线程是不是任务处理线程，因为销毁操作不可以在任务处理线程中进行</li>
<li>随后标记任务处理线程需要退出并唤醒线程执行相关任务</li>
<li>然后当前线程等待任务处理线程退出后唤醒主线程</li>
<li>主线程回收任务处理线程，最后释放任务队列对象</li>
</ul>
<h6 id="2-1-3-1-3-PostTask"><a href="#2-1-3-1-3-PostTask" class="headerlink" title="2.1.3.1.3. PostTask"></a>2.1.3.1.3. <code>PostTask</code></h6><div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">TaskQueueStdlib::PostTask</span><span class="params">(std::unique_ptr&lt;QueuedTask&gt; task)</span> </span>&#123;</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="function">rtc::CritScope <span class="title">lock</span><span class="params">(&amp;pending_lock_)</span></span>;</span><br><span class="line">    <span class="comment">// 序号自增赋值</span></span><br><span class="line">    OrderId order = thread_posting_order_++;</span><br><span class="line">    <span class="comment">// 加入到即时任务队列中</span></span><br><span class="line">    pending_queue_.<span class="built_in">push</span>(std::pair&lt;OrderId, std::unique_ptr&lt;QueuedTask&gt;&gt;(</span><br><span class="line">        order, std::<span class="built_in">move</span>(task)));</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 唤醒任务处理线程处理任务</span></span><br><span class="line">  <span class="built_in">NotifyWake</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h6 id="2-1-3-1-4-PostDelayedTask"><a href="#2-1-3-1-4-PostDelayedTask" class="headerlink" title="2.1.3.1.4. PostDelayedTask"></a>2.1.3.1.4. <code>PostDelayedTask</code></h6><div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">TaskQueueStdlib::PostDelayedTask</span><span class="params">(std::unique_ptr&lt;QueuedTask&gt; task,</span></span></span><br><span class="line"><span class="params"><span class="function">                                      <span class="type">uint32_t</span> milliseconds)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 计算延迟任务的执行时间（绝对时间）</span></span><br><span class="line">  <span class="keyword">auto</span> fire_at = rtc::<span class="built_in">TimeMillis</span>() + milliseconds;</span><br><span class="line"></span><br><span class="line">  DelayedEntryTimeout delay;</span><br><span class="line">  <span class="comment">// 设置延迟任务的执行时间</span></span><br><span class="line">  delay.next_fire_at_ms_ = fire_at;</span><br><span class="line"></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="function">rtc::CritScope <span class="title">lock</span><span class="params">(&amp;pending_lock_)</span></span>;</span><br><span class="line">    <span class="comment">// 序号自增赋值</span></span><br><span class="line">    delay.order_ = ++thread_posting_order_;</span><br><span class="line">    delayed_queue_[delay] = std::<span class="built_in">move</span>(task);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 唤醒任务处理线程处理任务</span></span><br><span class="line">  <span class="built_in">NotifyWake</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h2 id="3-总结"><a href="#3-总结" class="headerlink" title="3. 总结"></a>3. 总结</h2><p><code>TaskQueueStdlib</code>涉及到任务队列的核心实现方式，尤其是 <code>GetNextTask</code>和 <code>ProcessTasks</code>两个函数，需要理清相关的逻辑，从而了解整个模块的流程。</p>
]]></content>
      <tags>
        <tag>WebRTC源码分析</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机网络之RTP/RTCP</title>
    <url>/2022/12/08/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%B9%8BRTP-RTCP/</url>
    <content><![CDATA[<p>RTP标准实际上定义了一对协议：</p>
<ul>
<li><strong>实时传输协议</strong>（Real-time Transport Protocol，RTP），用于多媒体数据的交换</li>
<li><strong>实时传输控制协议</strong>（Real-time Transport Control Protocol，RTCP），用于周期性地发送与特定数据流相关联的控制信息<br>当在UDP上运行时，RTP数据流与相关联的RTCP控制流使用连续的传输层端口。RTP数据使用偶数端口号，RTCP控制信息使用相连的下一个（奇数）端口号。<br>RTP为Internet上端到端的实时传输提供时间信息和流同步，但并不保证服务质量，服务质量由RTCP来提供。</li>
</ul>
<h2 id="1-RTP协议格式"><a href="#1-RTP协议格式" class="headerlink" title="1. RTP协议格式"></a>1. RTP协议格式</h2><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line"> 0                   1                   2                   3</span><br><span class="line"> 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1</span><br><span class="line">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">|V=2|P|X|  CC   |M|     PT      |       sequence number         |</span><br><span class="line">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">|                           timestamp                           |</span><br><span class="line">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">|           synchronization source (SSRC) identifier            |</span><br><span class="line">+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+</span><br><span class="line">|            contributing source (CSRC) identifiers             |</span><br><span class="line">|                             ....                              |</span><br><span class="line">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br></pre></td></tr></table></figure></div>

<p>RTP报文由两部分组成：报头和有效载荷。RTP报头格式如上图所示，其中：</p>
<ol>
<li>V：RTP协议的<strong>版本号</strong>，占2位，当前协议版本号为2。</li>
<li>P：<strong>填充标志</strong>，占1位，如果P&#x3D;1，则在该报文的尾部填充一个或多个额外的八位组，它们不是有效载荷的一部分。</li>
<li>X：<strong>扩展标志</strong>，占1位，如果X&#x3D;1，则在RTP报头后跟有一个扩展报头。</li>
<li>CC：<strong>CSRC计数器</strong>，占4位，指示CSRC 标识符的个数。</li>
<li>M: <strong>标记</strong>，占1位，不同的有效载荷有不同的含义，对于视频，标记一帧的结束；对于音频，标记会话的开始。</li>
<li>PT: <strong>有效载荷类型</strong>，占7位，用于说明RTP报文中有效载荷的类型，如GSM音频、JPEM图像等,在流媒体中大部分是用来区分音频流和视频流的，这样便于客户端进行解析。</li>
<li><strong>序列号</strong>：占16位，用于标识发送者所发送的RTP报文的序列号，每发送一个报文，序列号增1。这个字段当下层的承载协议用UDP的时候，网络状况不好的时候可以用来检查丢包。同时出现网络抖动的情况可以用来对数据进行重新排序，在helix服务器中这个字段是从0开始的，同时音频包和视频包的<code>sequence</code>是分别记数的。</li>
<li>**时间戳(Timestamp)**：占32位，时戳反映了该RTP报文的第一个八位组的采样时刻。接收者使用时戳来计算延迟和延迟抖动，并进行同步控制。</li>
<li><strong>同步信源(SSRC)标识符</strong>：占32位，用于标识同步信源。该标识符是随机选择的，参加同一视频会议的两个同步信源不能有相同的SSRC。</li>
<li><strong>特约信源(CSRC)标识符</strong>：每个CSRC标识符占32位，可以有0～15个。每个CSRC标识了包含在该RTP报文有效载荷中的所有特约信源。</li>
</ol>
<p>如果扩展标志被置位则说明紧跟在报头后面是一个头扩展，其格式如下：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line"> 0                   1                   2                   3</span><br><span class="line"> 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1</span><br><span class="line">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">|      defined by profile       |           length              |</span><br><span class="line">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">|                        header extension                       |</span><br><span class="line">|                             ....                              |</span><br></pre></td></tr></table></figure></div>

<h2 id="2-RTCP协议"><a href="#2-RTCP协议" class="headerlink" title="2. RTCP协议"></a>2. RTCP协议</h2><h3 id="2-1-RTCP工作机制"><a href="#2-1-RTCP工作机制" class="headerlink" title="2.1. RTCP工作机制"></a>2.1. RTCP工作机制</h3><p><strong>当应用程序开始一个rtp会话时将使用两个端口：一个给RTP，一个给RTCP。</strong><br>RTP本身并不能为按顺序传送数据包提供可靠的传送机制，也不提供流量控制或拥塞控制，它依靠RTCP提供这些服务。<br>在RTP的会话之间周期的发放一些RTCP包以用来传监听服务质量和交换会话用户信息等功能。RTCP包中含有已发送的数据包的数量、丢失的数据包的数量等统计资料。<br>因此，服务器可以利用这些信息动态地改变传输速率，甚至改变有效载荷类型。RTP和RTCP配合使用，它们能以有效的反馈和最小的开销使传输效率最佳化，因而特别适合传送网上的实时数据。根据用户间的数据传输反馈信息，可以制定流量控制的策略，而会话用户信息的交互，可以制定会话控制的策略。<br>在RTCP通信控制中，RTCP协议的功能是通过不同的RTCP数据报来实现的，主要有如下几种类型：</p>
<h4 id="2-1-1-SR：发送端报告"><a href="#2-1-1-SR：发送端报告" class="headerlink" title="2.1.1. SR：发送端报告"></a>2.1.1. SR：发送端报告</h4><p>所谓发送端是指<strong>发出RTP数据报的应用程序或者终端</strong>，发送端同时也可以是接收端。</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line"> 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1</span><br><span class="line">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">|V=2|P|    RC   |   PT=SR=200   |             length L          |</span><br><span class="line">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">|                         SSRC of sender                        |</span><br><span class="line">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">|            NTP timestamp, most significant word NTS           |</span><br><span class="line">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">|             NTP timestamp, least significant word             |</span><br><span class="line">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">|                       RTP timestamp RTS                       |</span><br><span class="line">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">|                   sender&#x27;s packet count SPC                   |</span><br><span class="line">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">|                    sender&#x27;s octet count SOC                   |</span><br><span class="line">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">|                 SSRC_1 (SSRC of first source)                 |</span><br><span class="line">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">|fraction lost F|      cumulative number of packets lost C      |</span><br><span class="line">-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">|         extended highest sequence number received  EHSN       |</span><br><span class="line">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">|                    inter-arrival jitter J                     |</span><br><span class="line">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">|                          last SR LSR                          |</span><br><span class="line">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">|                    delay since last SR DLSR                   |</span><br><span class="line">+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+</span><br><span class="line">|                 SSRC_2 (SSRC of second source)                |</span><br><span class="line">:                               ...                             :</span><br><span class="line">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">|                  profile-specific extensions                  |</span><br><span class="line">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br></pre></td></tr></table></figure></div>

<ol>
<li><strong>版本</strong>（V）：2比特，RTCP版本。</li>
<li><strong>填充</strong>（P）：1比特，如果该位置为1，则该RTCP包的尾部就包含附加的填充字节。</li>
<li><strong>接收报告计数器</strong>（RC）：5比特，该SR包中的接收报告块的数目，可以为零。</li>
<li><strong>包类型</strong>（PT）：8比特，SR包是200。</li>
<li><strong>长度域</strong>（Length）：16比特，RTCP包的长度，包括填充的内容。</li>
<li><strong>同步源</strong>（SSRC of sender）：32比特，SR包发送者的同步源标识符。与对应RTP包中的SSRC一样。</li>
<li><strong>NTP timestamp</strong>（MSW+LWS）：64比特， 表示发送此报告时以挂钟时间测量的时间点。 结合来自各个接收器的接收报告中返回的时间戳，它可用于估计往返于接收器的往返传播时间。</li>
<li><strong>RTP timestamp</strong>：32比特，与NTP时间戳对应，与RTP数据包中的RTP时间戳具有相同的单位和随机初始值。</li>
<li><strong>Sender’s packet count</strong>：32比特，从开始发送包到产生这个SR包这段时间里，发送者发送的RTP数据包的总数. SSRC改变时，这个域清零。</li>
<li><strong>Sender&#96;s octet count</strong>：32比特，从开始发送包到产生这个SR包这段时间里，发送者发送的净荷数据的总字节数（不包括头部和填充）。发送者改变其SSRC时，这个域要清零。</li>
<li><strong>SSRC_n</strong>：32比特，在此块中报告其接收的发送者的 SSRC 标识符</li>
<li><strong>丢失率</strong>(Fraction Lost)：8比特，表明从上一个SR或RR包发出以来从同步源n(SSRC_n)来的RTP数据包的丢失率</li>
<li><strong>累计的包丢失数目</strong>（cumulative number of packets lost C ）：24比特，从开始接收到SSRC_n的包到发送SR,从SSRC_n传过来的RTP数据包的丢失总数。</li>
<li><strong>收到的扩展最大序列号</strong>(extended highest sequence number received  EHSN )：从SSRC_n收到的RTP数据包中最大的序列号</li>
<li><strong>接收抖动</strong>（Interarrival jitter）：32比特，RTP数据包接受时间的统计方差估计</li>
<li><strong>上次SR时间戳</strong>（Last SR,LSR）：32比特，取最近从SSRC_n收到的SR包中的NTP时间戳的中间32比特。如果目前还没收到SR包，则该域清零</li>
<li><strong>上次SR以来的延时</strong>（Delay since last SR,DLSR）：32比特，上次从SSRC_n收到SR包到发送本报告的延时</li>
<li><strong>扩展字段</strong> profile-specific extensions</li>
</ol>
<h4 id="2-1-2-RR：接收端报告"><a href="#2-1-2-RR：接收端报告" class="headerlink" title="2.1.2. RR：接收端报告"></a>2.1.2. RR：接收端报告</h4><p>所谓接收端是指仅接收但不发送RTP数据报的应用程序或者终端。<br><strong>除包类型代码外，SR与RR间唯一的差别是源报告包含有一个20字节发送者信息段。</strong>活动源在发出最后一个数据包之后或前一个数据包与下一个数据包间隔期间发送SR；否则，就发送RR。<br>SR和RR包都可没有接收报告块也可以包括多个接收报告块，其发布报告表示的源不一定是在CSRC列表上的起作用的源，每个接收报告块提供从特殊源接收数据的统计。最大可有31个接收报告块嵌入在SR 或 RR包中。<br>丢失包累计数差别给出间隔期间丢包的数量，而系列号的差别给出间隔期间希望发送的包数量，两者之比等于经过间隔期间包丢失百分比。<br>从发送者信息，第三方监控器可计算载荷平均数据速率与没收到数据间隔的平均包速率，两者比值给出平均载荷大小。<br>如假设包丢失与包大小无关，那么特殊接收者收到的包数量给出此接收者收到的表观流量。</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line"> 0                   1                   2                   3</span><br><span class="line"> 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1</span><br><span class="line">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">|V=2|P|    RC   |   PT=RR=201   |            length L           |</span><br><span class="line">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">|                     SSRC of packet sender                     |</span><br><span class="line">+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+</span><br><span class="line">|                 SSRC_1 (SSRC of first source)                 |</span><br><span class="line">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">| fraction lost |       cumulative number of packets lost       |</span><br><span class="line">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">|           extended highest sequence number received           |</span><br><span class="line">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">|                      inter-arrival jitter                     |</span><br><span class="line">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">|                         last SR (LSR)                         |</span><br><span class="line">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">|                   delay since last SR (DLSR)                  |</span><br><span class="line">+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+</span><br><span class="line">|                 SSRC_2 (SSRC of second source)                |</span><br><span class="line">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">:                               ...                             :</span><br><span class="line">+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+</span><br><span class="line">|                  profile-specific extensions                  |</span><br><span class="line">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br></pre></td></tr></table></figure></div>

<h4 id="2-1-3-SDES：源描述"><a href="#2-1-3-SDES：源描述" class="headerlink" title="2.1.3. SDES：源描述"></a>2.1.3. SDES：源描述</h4><p>主要功能是<strong>作为会话成员有关标识信息的载体</strong>，如用户名、邮件地址、电话号码等，此外还具有<strong>向会话成员传达会话控制信息的功能</strong>。<br>SDES源描述包提供了直观的文本信息来描述会话的参加者，包括CNAME、NAME、EMAIL、PHONE、LOC等源描述项，这些为接收方获取发送方的有关信息提供了方便。SDES 包由包头与数据块组成，数据块可以没有，也可有多个。</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line"> 0                   1                   2                   3</span><br><span class="line"> 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1</span><br><span class="line">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">|V=2|P|    SC   |  PT=SDES=202  |            length L           |</span><br><span class="line">+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+</span><br><span class="line">|                          SSRC/CSRC_1                          |</span><br><span class="line">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">|                           SDES items                          |</span><br><span class="line">|                              ...                              |</span><br><span class="line">+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+</span><br><span class="line">|                          SSRC/CSRC_2                          |</span><br><span class="line">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">|                           SDES items                          |</span><br><span class="line">|                              ...                              |</span><br><span class="line">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">|    CNAME=1    |     length    | user and domain name         ...</span><br><span class="line">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br></pre></td></tr></table></figure></div>

<p>V, P, PT, L:和RR包的描述一样，只不过其PT值为202<br>SC：5比特，此 SDES 数据包中包含的 SSRC&#x2F;CSRC 块的数量。<br>CNAME: <strong>规范终端标识SDES项</strong>，类似SSRC标识，RTCP为RTP连接中每一个参加者赋予唯一一个CNAME标识。在发生冲突或重启程序时，由于随机分配的SSRC标识可能发生变化，CNAME项可以提供从SSRC标识到仍为常量的源标识的绑定。为方便第三方监控，CNAME应适合程序或人员定位源。不同的 SDES 项根据类型-长度-值方案进行编码。 目前，CNAME、NAME、EMAIL、PHONE、LOC、TOOL、NOTE 和 PRIV 项目在 [RFC1889] 中定义。CNAME 项在每个 SDES 数据包中都是强制性的，而这又是每个复合 RTCP 数据包的强制性部分。与 SSRC 标识符一样，CNAME 必须与其他所有会话参与者的 CNAME 不同。 但不是随机选择 CNAME 标识符，CNAME 应该允许人或程序都可以通过 CNAME 内容来定位源。</p>
<h4 id="2-1-4-BYE：通知离开"><a href="#2-1-4-BYE：通知离开" class="headerlink" title="2.1.4. BYE：通知离开"></a>2.1.4. BYE：通知离开</h4><p>主要功能是<strong>指示某一个或者几个源不再有效</strong>，即通知会话中的其他成员自己将退出会话。<br>作为可选项，BYE包可包括一个8位八进制计数，后跟文本信息，表示离开原因，如：”cameramalfunction”或”RTPloop detected”。字符串的编码与在SDES 项中所描述的相同。如字符串信息至BYE包下32位边界结束处，字符串就不以空结尾；否则，BYE包以空八进制填充。</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line"> 0                   1                   2                   3</span><br><span class="line"> 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1</span><br><span class="line">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">|V=2|P|    SC   |   PT=BYE=203  |            length L           |</span><br><span class="line">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">|                           SSRC/CSRC                           |</span><br><span class="line">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">:                              ...                              :</span><br><span class="line">+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+</span><br><span class="line">|     length    |               reason for leaving (opt)       ... </span><br><span class="line">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br></pre></td></tr></table></figure></div>

<h4 id="2-1-5-APP：由应用程序自己定义"><a href="#2-1-5-APP：由应用程序自己定义" class="headerlink" title="2.1.5. APP：由应用程序自己定义"></a>2.1.5. APP：由应用程序自己定义</h4><p>解决了RTCP的扩展性问题，并且为协议的实现者提供了很大的灵活性。</p>
<h2 id="3-RTP报头扩展"><a href="#3-RTP报头扩展" class="headerlink" title="3. RTP报头扩展"></a>3. RTP报头扩展</h2><h3 id="3-1-RTP报头"><a href="#3-1-RTP报头" class="headerlink" title="3.1. RTP报头"></a>3.1. RTP报头</h3><p>RTP协议中，RTP Header（报头）包括<strong>固定报头</strong>（Fixed Header）与<strong>报头扩展</strong>（Header extension，可选）。<br>RTP Fixed Header结构如下，其中前12字节是每个RTP包必须包含的。</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line"> 0                   1                   2                   3</span><br><span class="line"> 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1</span><br><span class="line">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">|V=2|P|X|  CC   |M|     PT      |       sequence number         |</span><br><span class="line">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">|                           timestamp                           |</span><br><span class="line">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">|           synchronization source (SSRC) identifier            |</span><br><span class="line">+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+</span><br><span class="line">|            contributing source (CSRC) identifiers             |</span><br><span class="line">|                             ....                              |</span><br><span class="line">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br></pre></td></tr></table></figure></div>

<p>固定报头携带的信息满足不了更复杂的需求，所以引入RTP报头扩展，可以携带更多的信息。</p>
<h3 id="3-2-RTP报头扩展"><a href="#3-2-RTP报头扩展" class="headerlink" title="3.2. RTP报头扩展"></a>3.2. RTP报头扩展</h3><p>如果RTP Fixed Header中，X字段为1，说明后面跟着RTP Header Extension。RTP Header Extension结构如下：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line"> 0                   1                   2                   3</span><br><span class="line"> 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1</span><br><span class="line">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">|      defined by profile       |           length              |</span><br><span class="line">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">|                        header extension                       |</span><br><span class="line">|                             ....                              |</span><br></pre></td></tr></table></figure></div>

<ul>
<li><code>defined by profile</code>：决定使用哪种Header Extension：<strong>one-byte</strong>或者<strong>two-byte</strong> header</li>
<li><code>length</code>：表示Header Extension的长度：<code>length x 4</code>字节</li>
</ul>
<h4 id="3-2-1-One-byte-header"><a href="#3-2-1-One-byte-header" class="headerlink" title="3.2.1. One-byte header"></a>3.2.1. One-byte header</h4><p>对于One-Byte Header，”defined by profile”字段为固定的0xBEDE。接着后面的结构如下：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line"> 0</span><br><span class="line"> 0 1 2 3 4 5 6 7</span><br><span class="line">+-+-+-+-+-+-+-+-+</span><br><span class="line">|  ID   |  len  |</span><br><span class="line">+-+-+-+-+-+-+-+-+</span><br></pre></td></tr></table></figure></div>

<ul>
<li>ID:4 bit长度的ID表示本地标识符</li>
<li>len:表示extension data长度，<strong>范围：0~15，为0表示长度为1字节，15表示16字节</strong></li>
</ul>
<p>如下是一个One-Byte Header的示例：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line"> 0                   1                   2                   3</span><br><span class="line"> 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1</span><br><span class="line">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">|       0xBE    |    0xDE       |           length=3            |</span><br><span class="line">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">|  ID   | L=0   |     data      |  ID   |  L=1  |   data...</span><br><span class="line">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">...data   |    0 (pad)    |    0 (pad)    |  ID   | L=3   |</span><br><span class="line">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">|                          data                                 |</span><br><span class="line">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br></pre></td></tr></table></figure></div>

<p>首先是<code>0xBEDE</code>固定字段开头，接着length长度为3，说明后面跟着<code>3x4</code>字节长度的header extension。</p>
<ul>
<li>对于第一个header extension：<code>L=0</code>，表示data长度为1字节。</li>
<li>对于第二个header extension：<code>L=1</code>，表示data长度为2字节。由于按4字节对齐，所以接着是值为0的填充数据。</li>
<li>对于最后一个header extension：<code>L=3</code>，表示data长度为4字节。</li>
</ul>
<h4 id="3-2-2-Two-Byte-Header"><a href="#3-2-2-Two-Byte-Header" class="headerlink" title="3.2.2. Two-Byte Header"></a>3.2.2. Two-Byte Header</h4><p><code>defined by profile</code>字段结构如下：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line"> 0                   1</span><br><span class="line"> 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5</span><br><span class="line">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">|         0x100         |appbits|</span><br><span class="line">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br></pre></td></tr></table></figure></div>

<p>接着后面的每个扩展元素结构如下：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line"> 0                   1</span><br><span class="line"> 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5</span><br><span class="line">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">|       ID      |     length    |</span><br><span class="line">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br></pre></td></tr></table></figure></div>

<ul>
<li>ID：本地标识符</li>
<li>length:表示extension data长度，范围1~255<br>如下是一个Two-Byte Header示例：</li>
</ul>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line"> 0                   1                   2                   3</span><br><span class="line"> 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1</span><br><span class="line">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">|      0x10     |      0x00     |           length=3            |</span><br><span class="line">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">|       ID      |     L=0       |       ID      |      L=1      |</span><br><span class="line">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">|      data     |    0 (pad)    |       ID      |      L=4      |</span><br><span class="line">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">|                             data                              |</span><br><span class="line">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br></pre></td></tr></table></figure></div>

<p>首先<code>defined by profile</code>字段为0x1000，length为3，后面跟着3x4字节长度扩展。</p>
<ul>
<li>对于第一个header extension：<code>L=0</code>，数据长度为0</li>
<li>对于第二个header extension：<code>L=1</code>，data长度为1，接着是填充数据</li>
<li>对于第三个header extension：<code>L=4</code>，后面跟着4字节长度数据</li>
</ul>
]]></content>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
</search>
