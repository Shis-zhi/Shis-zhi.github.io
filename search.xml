<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>C++关键字之explicit</title>
    <url>/2022/12/06/C++%E5%85%B3%E9%94%AE%E5%AD%97%E4%B9%8Bexplicit/</url>
    <content><![CDATA[<p>在C++中 <code>explicit</code>关键字只能用来修饰单参构造函数。</p>
<p>与之对应的关键字为 <code>implicit</code>，其含义为“隐式的”，类的构造函数默认声明为 <code>implicit</code>。</p>
<h2 id="1-隐式声明的构造函数"><a href="#1-隐式声明的构造函数" class="headerlink" title="1. 隐式声明的构造函数"></a>1. 隐式声明的构造函数</h2><div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">CxString</span></span><br><span class="line">&#123;  </span><br><span class="line"><span class="keyword">public</span>:  </span><br><span class="line">    <span class="type">char</span> *_pstr;  </span><br><span class="line">    <span class="type">int</span> _size;  </span><br><span class="line">    <span class="built_in">CxString</span>(<span class="type">int</span> size)  </span><br><span class="line">    &#123;  </span><br><span class="line">        _size = size;                       <span class="comment">// string的预设大小  </span></span><br><span class="line">        _pstr = (<span class="type">char</span>*)<span class="built_in">malloc</span>(size + <span class="number">1</span>);    <span class="comment">// 分配string的内存  </span></span><br><span class="line">        <span class="built_in">memset</span>(_pstr, <span class="number">0</span>, size + <span class="number">1</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="built_in">CxString</span>(<span class="type">const</span> <span class="type">char</span> *p)  </span><br><span class="line">    &#123;  </span><br><span class="line">        <span class="type">int</span> size = <span class="built_in">strlen</span>(p);  </span><br><span class="line">        _pstr = (<span class="type">char</span>*)<span class="built_in">malloc</span>(size + <span class="number">1</span>);    <span class="comment">// 分配string的内存  </span></span><br><span class="line">        <span class="built_in">strcpy</span>(_pstr, p);            <span class="comment">// 复制字符串  </span></span><br><span class="line">        _size = <span class="built_in">strlen</span>(_pstr);  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="comment">// 析构函数这里不讨论, 省略...  </span></span><br><span class="line">&#125;;  </span><br><span class="line">    <span class="comment">// 下面是调用:  </span></span><br><span class="line">  </span><br><span class="line">    <span class="function">CxString <span class="title">string1</span><span class="params">(<span class="number">1</span>)</span></span>;      <span class="comment">// 正确，调用 CxString(int size) </span></span><br><span class="line">    CxString string2 = <span class="number">2</span>;     <span class="comment">// 正确，调用 CxString(int size)   </span></span><br><span class="line">    CxString string3;         <span class="comment">// 错误，无默认的构造函数</span></span><br><span class="line">    <span class="function">CxString <span class="title">string4</span><span class="params">(<span class="string">&quot;123&quot;</span>)</span></span>;  <span class="comment">// 正确，调用 CxString(const char *p) </span></span><br><span class="line">    CxString string5 = <span class="string">&quot;456&quot;</span>; <span class="comment">// 正确，调用 CxString(const char *p) </span></span><br><span class="line">    CxString string6 = <span class="string">&#x27;a&#x27;</span>;   <span class="comment">// 正确，但是调用 CxString(int size)，size的值为&#x27;a&#x27;的ascii码</span></span><br></pre></td></tr></table></figure></div>

<p>在C++中，如果构造函数只有一个参数时，在编译的时候就会有一个缺省的类型转换操作，也就是将对应的数据类型转换为该类对象。所以说：</p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line">CxString string2 = <span class="number">2</span>;</span><br></pre></td></tr></table></figure></div>

<p>实际上等同于：</p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">CxString <span class="title">string2</span><span class="params">(<span class="number">2</span>)</span></span>;</span><br><span class="line"><span class="comment">// 或以下形式</span></span><br><span class="line"><span class="function">CxString <span class="title">tmp</span><span class="params">(<span class="number">2</span>)</span></span>;</span><br><span class="line">CxString string2 = tmp;   </span><br></pre></td></tr></table></figure></div>

<p>关于<code>string6</code>的情况类似，只不过将<code>&#39;a&#39;</code>转化成了对应的ascii码。<br>但是以上两种写法并不具有很好的可读性，为了避免这种情况产生，可以使用<code>explicit</code>关键字阻止隐式的自动类型转换。</p>
<h2 id="2-显式声明的构造函数"><a href="#2-显式声明的构造函数" class="headerlink" title="2.显式声明的构造函数"></a>2.显式声明的构造函数</h2><p>使用<code>explicit</code>关键字可以阻止类构造函数的隐式类型转换。</p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">CxString</span></span><br><span class="line">&#123;  </span><br><span class="line"><span class="keyword">public</span>:  </span><br><span class="line">    <span class="type">char</span> *_pstr;  </span><br><span class="line">    <span class="type">int</span> _size;  </span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">CxString</span><span class="params">(<span class="type">int</span> size)</span>  </span></span><br><span class="line"><span class="function">    </span>&#123;  </span><br><span class="line">        _size = size;                       <span class="comment">// string的预设大小  </span></span><br><span class="line">        _pstr = (<span class="type">char</span>*)<span class="built_in">malloc</span>(size + <span class="number">1</span>);    <span class="comment">// 分配string的内存  </span></span><br><span class="line">        <span class="built_in">memset</span>(_pstr, <span class="number">0</span>, size + <span class="number">1</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="built_in">CxString</span>(<span class="type">const</span> <span class="type">char</span> *p)  </span><br><span class="line">    &#123;  </span><br><span class="line">        <span class="type">int</span> size = <span class="built_in">strlen</span>(p);  </span><br><span class="line">        _pstr = (<span class="type">char</span>*)<span class="built_in">malloc</span>(size + <span class="number">1</span>);    <span class="comment">// 分配string的内存  </span></span><br><span class="line">        <span class="built_in">strcpy</span>(_pstr, p);            <span class="comment">// 复制字符串  </span></span><br><span class="line">        _size = <span class="built_in">strlen</span>(_pstr);  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="comment">// 析构函数这里不讨论, 省略...  </span></span><br><span class="line">&#125;;  </span><br><span class="line">    <span class="comment">// 下面是调用:  </span></span><br><span class="line">  </span><br><span class="line">    <span class="function">CxString <span class="title">string1</span><span class="params">(<span class="number">1</span>)</span></span>;      <span class="comment">// 正确，调用 CxString(int size) </span></span><br><span class="line">    CxString string2 = <span class="number">2</span>;     <span class="comment">// 错误  </span></span><br><span class="line">    CxString string3;         <span class="comment">// 错误，无默认的构造函数</span></span><br><span class="line">    <span class="function">CxString <span class="title">string4</span><span class="params">(<span class="string">&quot;123&quot;</span>)</span></span>;  <span class="comment">// 正确，调用 CxString(const char *p) </span></span><br><span class="line">    CxString string5 = <span class="string">&quot;456&quot;</span>; <span class="comment">// 正确，调用 CxString(const char *p)</span></span><br><span class="line">    CxString string6 = <span class="string">&#x27;a&#x27;</span>;   <span class="comment">// 正确，但是调用 CxString(int size)，size的值为&#x27;a&#x27;的ascii码</span></span><br></pre></td></tr></table></figure></div>]]></content>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>WebRTC源码分析之任务队列-TaskQueueBase</title>
    <url>/2022/12/06/WebRTC%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E4%B9%8B%E4%BB%BB%E5%8A%A1%E9%98%9F%E5%88%97-TaskQueueBase/</url>
    <content><![CDATA[<h1 id="1-前言"><a href="#1-前言" class="headerlink" title="1. 前言"></a>1. 前言</h1><p>任务队列 <code>TaskQueue</code>是WebRTC中非常核心的一部分，其主要功能是将任务投递到某一个线程执行。<code>TaskQueue</code>是WebRTC中进程交互很重要的方式。<br>本文主要分析 <code>TaskQueue</code>中最重要的基类 <code>TaskQueueBase</code>。<br><code>TaskQueue</code>机制中涉及的其他类后续会继续补充。<br>WebRTC版本：M84</p>
<h1 id="2-正文"><a href="#2-正文" class="headerlink" title="2. 正文"></a>2. 正文</h1><h2 id="2-0-预说明：线程局部存储"><a href="#2-0-预说明：线程局部存储" class="headerlink" title="2.0. 预说明：线程局部存储"></a>2.0. 预说明：线程局部存储</h2><p>任务队列不可避免地涉及到多线程的知识，此处仅简单介绍一下 <code>TaskQueueBase</code>部分涉及到的相关内容以及函数。</p>
<h3 id="2-0-1-线程局部存储概念"><a href="#2-0-1-线程局部存储概念" class="headerlink" title="2.0.1. 线程局部存储概念"></a>2.0.1. 线程局部存储概念</h3><p>线程局部存储（TLS，Thread Local Storage）是线程私有的全局变量。普通的全局变量是多个线程共享的，一个线程对其修改，所有线程均可见。而线程局部存储是线程私有的，每个线程都有自己的一个副本，某个线程对其所做修改只会修改自己的副本，不会影响到其他线程的副本。</p>
<h3 id="2-0-2-pthread-key-t"><a href="#2-0-2-pthread-key-t" class="headerlink" title="2.0.2. pthread_key_t"></a>2.0.2. <code>pthread_key_t</code></h3><div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line">ABSL_CONST_INIT <span class="type">pthread_key_t</span> g_queue_ptr_tls = <span class="number">0</span>;</span><br></pre></td></tr></table></figure></div>

<p>上述声明中 <code>pthread_key_t</code>为前一小节提到的线程局部存储类型</p>
<h3 id="2-0-3-Tls相关函数说明"><a href="#2-0-3-Tls相关函数说明" class="headerlink" title="2.0.3. Tls相关函数说明"></a>2.0.3. <code>Tls</code>相关函数说明</h3><div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">pthread_key_create</span><span class="params">(<span class="type">pthread_key_t</span> *key, <span class="type">void</span> (*destructor)(<span class="type">void</span>*))</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">pthread_setspecific</span><span class="params">(<span class="type">pthread_key_t</span> key, <span class="type">const</span> <span class="type">void</span> *value)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span>* <span class="title">pthread_getspecific</span><span class="params">(<span class="type">pthread_key_t</span> key)</span></span>;</span><br></pre></td></tr></table></figure></div>

<ul>
<li>调用 <code>pthread_key_create</code>函数可以创建 <code>pthread_key_t</code>变量。该函数需要提供两个参数，第一个参数是需要创建的 <code>pthread_key_t</code>变量，第二个参数是一个释放函数，在线程释放其 <code>Tls</code>的时候被调用。如果函数指针被设置成 <code>nullptr</code>，那么系统将调用默认释放函数。该函数成功创建变量时返回0，其他任何返回值均代表出现异常。</li>
<li>当线程中需要存储值的时候，可以调用 <code>pthread_setspcific</code>函数。该函数需要提供两个参数，第一个参数为前面声明的 <code>pthread_key_t</code>变量，第二个为 <code>void*</code>变量，也就意味着可以存储任何类型的值。</li>
<li>如果需要取出所存储的值，调用 <code>pthread_getspecific</code>函数。该函数的参数为前面提到的 <code>pthread_key_t</code>变量，该函数返回 <code>void *</code>类型的值，如需使用，则要进行强制类型转换。</li>
</ul>
<h3 id="2-0-4-InitializeTls"><a href="#2-0-4-InitializeTls" class="headerlink" title="2.0.4. InitializeTls"></a>2.0.4. <code>InitializeTls</code></h3><div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">InitializeTls</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">RTC_CHECK</span>(<span class="built_in">pthread_key_create</span>(&amp;g_queue_ptr_tls, <span class="literal">nullptr</span>)==<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p><code>RTC_CHECK()</code>为WebRTC中的断言宏，当其内部参数为 <code>false</code>时，抛出异常，直接中止当前进程。</p>
<h3 id="2-0-5-GetQueuePtrTls"><a href="#2-0-5-GetQueuePtrTls" class="headerlink" title="2.0.5. GetQueuePtrTls"></a>2.0.5. <code>GetQueuePtrTls</code></h3><div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">pthread_key_t</span> <span class="title">GetQueuePtrTls</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">pthread_once_t</span> init_once = PTHREAD_ONCE_INIT;</span><br><span class="line">    <span class="built_in">RTC_CHECK</span>(<span class="built_in">pthread_once</span>(&amp;init_once, &amp;InitializeTls) == <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> g_queue_ptr_tls; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>调用 <code>pthread_once()</code>函数，传入初值为 <code>PTHREAD_ONCE_INIT</code>的 <code>init_once</code>变量，结合 <code>RTC_CHECK()</code>断言保证 <code>InitializeTls()</code>函数仅执行一次。</p>
<h3 id="2-0-6-说明"><a href="#2-0-6-说明" class="headerlink" title="2.0.6. 说明"></a>2.0.6. 说明</h3><ul>
<li>上述所有函数为全局函数 不属于任何一个对象</li>
<li>上述所有函数只在 <code>WEBRTC_POSIX</code>宏定义的前提下被定义，否则不被定义</li>
<li>定义这些函数是为了供 <code>TaskQueueBase</code>类使用</li>
</ul>
<h2 id="2-1-QueuedTask类"><a href="#2-1-QueuedTask类" class="headerlink" title="2.1. QueuedTask类"></a>2.1. <code>QueuedTask</code>类</h2><blockquote>
<p>Path:<br>api\task_queue\queued_task.h</p>
</blockquote>
<h3 id="2-1-1-类声明"><a href="#2-1-1-类声明" class="headerlink" title="2.1.1. 类声明"></a>2.1.1. 类声明</h3><div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">namespace</span> webrtc&#123;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">QueuedTask</span>&#123;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">QueuedTask</span>() = <span class="keyword">default</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">bool</span> <span class="title">Run</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;<span class="comment">// class QueuedTask</span></span><br><span class="line">&#125; <span class="comment">// namespace webrtc</span></span><br></pre></td></tr></table></figure></div>

<p><code>QueueTask</code>是一个抽象类，为需要异步执行的任务提供基本接口。<br>这个接口由一个单一的函数 <code>Run()</code>组成，它会在目标队列上执行，<code>Run()</code>具体实现的功能由其子类决定。</p>
<h2 id="2-2-TaskQueueBase类"><a href="#2-2-TaskQueueBase类" class="headerlink" title="2.2. TaskQueueBase类"></a>2.2. <code>TaskQueueBase</code>类</h2><blockquote>
<p>Path:<br>api\task_queue\task_queue_base.h<br>api\task_queue\task_queue_base.cc</p>
</blockquote>
<h3 id="2-2-1-类声明"><a href="#2-2-1-类声明" class="headerlink" title="2.2.1. 类声明"></a>2.2.1. 类声明</h3><div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">namespace</span> webrtc&#123;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">RTC_LOCKABLE</span> RTC_EXPORT TaskQueueBase &#123;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Delete</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">PostTask</span><span class="params">(std::unique_ptr&lt;QueuedTask&gt; task)</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">PostDelayedTask</span><span class="params">(std::unique_ptr&lt;QueuedTask&gt; task,</span></span></span><br><span class="line"><span class="params"><span class="function">                                 <span class="type">uint32_t</span> milliseconds)</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="type">static</span> TaskQueueBase* <span class="title">Current</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">IsCurrent</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> Current == <span class="keyword">this</span>; &#125;</span><br><span class="line">  <span class="keyword">protected</span>:</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">CurrentTaskQueueSetter</span>&#123;</span><br><span class="line">      <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="keyword">explicit</span> <span class="title">CurrentTaskQueueSetter</span><span class="params">(TaskQueueBase* task_queue)</span></span>;</span><br><span class="line">        <span class="built_in">CurrentTaskQueueSetter</span>(<span class="type">const</span> CurrentTaskQueueSetter&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">        CurrentTaskQueueSetter&amp; <span class="keyword">operator</span>=(<span class="type">const</span> CurrentTaskQueueSetter&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">        ~<span class="built_in">CurrentTaskQueueSetter</span>();</span><br><span class="line">      <span class="keyword">private</span>:</span><br><span class="line">        TaskQueueBase* <span class="type">const</span> previous_;</span><br><span class="line">    &#125;;<span class="comment">// class CurrentTaskQueueSetter</span></span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">TaskQueueBase</span>() = <span class="keyword">default</span>;</span><br><span class="line">  </span><br><span class="line">&#125;;<span class="comment">// class TaskQueueBase</span></span><br><span class="line">&#125; <span class="comment">// namespace webrtc</span></span><br></pre></td></tr></table></figure></div>

<h3 id="2-2-2-函数实现及相关说明"><a href="#2-2-2-函数实现及相关说明" class="headerlink" title="2.2.2. 函数实现及相关说明"></a>2.2.2. 函数实现及相关说明</h3><h4 id="2-2-2-1-Delete"><a href="#2-2-2-1-Delete" class="headerlink" title="2.2.2.1. Delete"></a>2.2.2.1. <code>Delete</code></h4><div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Delete</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br></pre></td></tr></table></figure></div>

<p>纯虚函数，基类中无需实现。<br>调用此函数开始销毁任务队列，此函数在返回时需要确保没有任务正在运行，也没有新的任务能够在任务队列中启动。<br>同时此函数负责释放对象，释放动作可以在 <code>Delete</code>期间同步进行，也可以在 <code>Delete</code>之后异步进行。<br>销毁某个任务队列对不在此任务队列中的任务不产生任何影响，这些任务也不会因为其他的任务队列销毁而调用任何函数。<br>在任务队列上执行的任务不可以调用 <code>Delete</code>,但是可以调用其他的函数，比如 <code>PostTask</code>。</p>
<h4 id="2-2-2-2-PostTask"><a href="#2-2-2-2-PostTask" class="headerlink" title="2.2.2.2. PostTask"></a>2.2.2.2. <code>PostTask</code></h4><div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">PostTask</span><span class="params">(std::unique_ptr&lt;QueuedTask&gt; task)</span> </span>= <span class="number">0</span>;</span><br></pre></td></tr></table></figure></div>

<p>纯虚函数，基类中无需实现。<br>此函数用于安排一个即时任务的处理，这些任务按照先进先出的顺序执行（所以称为任务队列）。<br>如果 <code>task-&gt;Run()</code>的返回值是 <code>true</code>,代表任务成功执行，任务会在下一个 <code>QueuedTask</code>开始执行之前从任务队列中被移除。</p>
<h4 id="2-2-2-3-PostDelayTask"><a href="#2-2-2-3-PostDelayTask" class="headerlink" title="2.2.2.3. PostDelayTask"></a>2.2.2.3. <code>PostDelayTask</code></h4><div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">PostDelayedTask</span><span class="params">(std::unique_ptr&lt;QueuedTask&gt; task, </span></span></span><br><span class="line"><span class="params"><span class="function">                                           <span class="type">uint32_t</span> milliseconds)</span> </span>= <span class="number">0</span>;</span><br></pre></td></tr></table></figure></div>

<p>纯虚函数，基类中无需实现。<br>此函数用于安排一个延迟任务的处理，处理会在调用 <code>PostDelayedTask</code>函数后的 <code>milliseconds</code>毫秒后执行。<br>关于延迟时间的精度可以称作“尽力而为”，在某些场景下，定时可能会有一些毫秒级的误差。</p>
<h4 id="2-2-2-4-Current和-IsCurrent"><a href="#2-2-2-4-Current和-IsCurrent" class="headerlink" title="2.2.2.4. Current和 IsCurrent"></a>2.2.2.4. <code>Current</code>和 <code>IsCurrent</code></h4><p>需要说明的是，从此处开始，相关的的定义会根据所定义的宏而不同，代码块中会给出相关说明。<br>变量及函数声明：</p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> TaskQueueBase* <span class="title">Current</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">IsCurrent</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> <span class="built_in">Current</span>() == <span class="keyword">this</span>; &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//if defined ABSL_HAVE_THREAD_LOCAL</span></span><br><span class="line">ABSL_CONST_INIT <span class="keyword">thread_local</span> TaskQueueBase* current = <span class="literal">nullptr</span>;</span><br></pre></td></tr></table></figure></div>

<p><code>Current()</code>函数定义：</p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// defined ABSL_HAVE_THREAD_LOCAL</span></span><br><span class="line"><span class="function">TaskQueueBase* <span class="title">TaskQueueBase::Current</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> current;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// defined WEBRTC_POSIX</span></span><br><span class="line"><span class="function">TaskQueueBase* <span class="title">TaskQueueBase::Current</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">static_cast</span>&lt;TaskQueueBase*&gt;(<span class="built_in">pthread_getspecific</span>(<span class="built_in">GetQueuePtrTls</span>()));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p><code>Current()</code>函数返回当前线程保存的任务队列，返回值为一个 <code>static</code>变量。<br><code>IsCurrent()</code>函数则用于判断当前线程保存的任务队列是不是对象本身。</p>
<h3 id="2-2-3-说明"><a href="#2-2-3-说明" class="headerlink" title="2.2.3. 说明"></a>2.2.3. 说明</h3><ul>
<li><code>TaskQueueBase</code>是抽象基类，只用于提供接口，不可以被实例化</li>
<li>基于上一条说明，<code>TaskQueueBase</code>的析构函数被声明为虚函数</li>
<li>考虑到文章结构，<code>TaskQueueBase</code>的成员类会在下一节介绍</li>
</ul>
<h2 id="2-3-TaskQueue-CurrentTaskQueueSetter类"><a href="#2-3-TaskQueue-CurrentTaskQueueSetter类" class="headerlink" title="2.3. TaskQueue::CurrentTaskQueueSetter类"></a>2.3. <code>TaskQueue::CurrentTaskQueueSetter</code>类</h2><blockquote>
<p>Path:<br>api\task_queue\task_queue_base.h<br>api\task_queue\task_queue_base.cc</p>
</blockquote>
<h3 id="2-3-1-类声明"><a href="#2-3-1-类声明" class="headerlink" title="2.3.1. 类声明"></a>2.3.1. 类声明</h3><div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">namespace</span> webrtc &#123;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">RTC_LOCKABLE</span> RTC_EXPORT TaskQueueBase &#123;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">  <span class="keyword">class</span> <span class="title class_">RTC_EXPORT</span> CurrentTaskQueueSetter &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">CurrentTaskQueueSetter</span><span class="params">(TaskQueueBase* task_queue)</span></span>;</span><br><span class="line">    <span class="built_in">CurrentTaskQueueSetter</span>(<span class="type">const</span> CurrentTaskQueueSetter&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">    CurrentTaskQueueSetter&amp; <span class="keyword">operator</span>=(<span class="type">const</span> CurrentTaskQueueSetter&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">    ~<span class="built_in">CurrentTaskQueueSetter</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">    TaskQueueBase* <span class="type">const</span> previous_;</span><br><span class="line">  &#125;;<span class="comment">// class CurrentTaskQueueSetter</span></span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;;<span class="comment">// class TaskQueueBase</span></span><br><span class="line">&#125;<span class="comment">// namespace webrtc</span></span><br></pre></td></tr></table></figure></div>

<h3 id="2-3-2-函数实现及相关说明"><a href="#2-3-2-函数实现及相关说明" class="headerlink" title="2.3.2.函数实现及相关说明"></a>2.3.2.函数实现及相关说明</h3><h4 id="2-3-2-1-CurrentTaskQueueSetter"><a href="#2-3-2-1-CurrentTaskQueueSetter" class="headerlink" title="2.3.2.1. CurrentTaskQueueSetter"></a>2.3.2.1. <code>CurrentTaskQueueSetter</code></h4><div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// defined ABSL_HAVE_THREAD_LOCAL</span></span><br><span class="line">TaskQueueBase::CurrentTaskQueueSetter::<span class="built_in">CurrentTaskQueueSetter</span>(</span><br><span class="line">    TaskQueueBase* task_queue)</span><br><span class="line">    : <span class="built_in">previous_</span>(current) &#123;</span><br><span class="line">  current = task_queue;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// defined WEBRTC_POSIX</span></span><br><span class="line">TaskQueueBase::CurrentTaskQueueSetter::<span class="built_in">CurrentTaskQueueSetter</span>(</span><br><span class="line">    TaskQueueBase* task_queue)</span><br><span class="line">    : <span class="built_in">previous_</span>(TaskQueueBase::<span class="built_in">Current</span>()) &#123;</span><br><span class="line">  <span class="built_in">pthread_setspecific</span>(<span class="built_in">GetQueuePtrTls</span>(), task_queue);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>构造函数主要的任务分为两部分：</p>
<ul>
<li>使用 <code>previous_</code>暂存当前线程的任务队列</li>
<li>将 <code>task_queue</code>存放在当前线程的 <code>Tls</code>中</li>
</ul>
<h4 id="2-3-2-2-CurrentTaskQueueSetter"><a href="#2-3-2-2-CurrentTaskQueueSetter" class="headerlink" title="2.3.2.2. ~CurrentTaskQueueSetter"></a>2.3.2.2. <code>~CurrentTaskQueueSetter</code></h4><div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// defined ABSL_HAVE_THREAD_LOCAL</span></span><br><span class="line">TaskQueueBase::CurrentTaskQueueSetter::~<span class="built_in">CurrentTaskQueueSetter</span>() &#123;</span><br><span class="line">  current = previous_;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// defined WEBRTC_POSIX</span></span><br><span class="line">TaskQueueBase::CurrentTaskQueueSetter::~<span class="built_in">CurrentTaskQueueSetter</span>() &#123;</span><br><span class="line">  <span class="built_in">pthread_setspecific</span>(<span class="built_in">GetQueuePtrTls</span>(), previous_);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>构造函数的任务就是将之前暂存在 <code>previous_</code>的任务队列取出，重新放回到当前线程的 <code>Tls</code>当中。</p>
<h3 id="2-3-3-说明"><a href="#2-3-3-说明" class="headerlink" title="2.3.3.说明"></a>2.3.3.说明</h3><p><code>CurrentTaskQueueSetter</code>类只在构造和析构时执行任务：</p>
<ul>
<li>构造时，用传入构造函数的任务队列更新当前线程存放的任务队列，并将更新前的任务队列暂存</li>
<li>析构时，用构造时暂存的任务队列更新当前线程存放的任务队列</li>
</ul>
<h1 id="3-总结"><a href="#3-总结" class="headerlink" title="3. 总结"></a>3. 总结</h1><p><code>TaskQueueBase</code>类作为任务队列机制的核心基类，在后续分析中经常会涉及到，了解其实现方法有助于了解整个任务队列的运行机制。<br>关于任务队列的其他类，后续会在其他文章中进行分析。</p>
]]></content>
      <tags>
        <tag>WebRTC</tag>
      </tags>
  </entry>
  <entry>
    <title>WebRTC源码分析之任务队列-TaskQueueStdlib</title>
    <url>/2022/12/06/WebRTC%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E4%B9%8B%E4%BB%BB%E5%8A%A1%E9%98%9F%E5%88%97-TaskQueueStdlib/</url>
    <content><![CDATA[<h1 id="1-前言"><a href="#1-前言" class="headerlink" title="1. 前言"></a>1. 前言</h1><p><code>TaskQueueStdlib</code>类是WebRTC任务队列机制的核心类，也是整个任务队列的标准库，在阅读本文之前，需要对 <code>TaskQueueBase</code>类有一定了解。<br>可以参考这篇文章<a class="link"   href="https://juejin.cn/post/7164758663478018056" >WebRTC源码分析-TaskQueue（任务队列）-TaskQueueBase<i class="fas fa-external-link-alt"></i></a><br>WebRTC版本：M84</p>
<h1 id="2-正文"><a href="#2-正文" class="headerlink" title="2. 正文"></a>2. 正文</h1><h2 id="2-0-预说明：TaskQueuePriorityToThreadPriority"><a href="#2-0-预说明：TaskQueuePriorityToThreadPriority" class="headerlink" title="2.0. 预说明：TaskQueuePriorityToThreadPriority"></a>2.0. 预说明：<code>TaskQueuePriorityToThreadPriority</code></h2><div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">rtc::ThreadPriority <span class="title">TaskQueuePriorityToThreadPriority</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    TaskQueueFactory::Priority priority)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">switch</span> (priority) &#123;</span><br><span class="line">    <span class="keyword">case</span> TaskQueueFactory::Priority::HIGH:</span><br><span class="line">      <span class="keyword">return</span> rtc::kRealtimePriority;</span><br><span class="line">    <span class="keyword">case</span> TaskQueueFactory::Priority::LOW:</span><br><span class="line">      <span class="keyword">return</span> rtc::kLowPriority;</span><br><span class="line">    <span class="keyword">case</span> TaskQueueFactory::Priority::NORMAL:</span><br><span class="line">      <span class="keyword">return</span> rtc::kNormalPriority;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      <span class="built_in">RTC_NOTREACHED</span>();</span><br><span class="line">      <span class="keyword">return</span> rtc::kNormalPriority;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>此函数用于将任务队列的优先级转换为线程的优先级。<br><code>TaskQueueFactory::Priority</code>定义如下：</p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">enum class</span> <span class="title class_">Priority</span> &#123; NORMAL = <span class="number">0</span>, HIGH, LOW &#125;;</span><br></pre></td></tr></table></figure></div>

<h2 id="2-1-TaskQueueStdlib类"><a href="#2-1-TaskQueueStdlib类" class="headerlink" title="2.1. TaskQueueStdlib类"></a>2.1. <code>TaskQueueStdlib</code>类</h2><blockquote>
<p>path:<br>rtc_base\task_queue_stdlib.h<br>rtc_base\task_queue_stdlib.cc</p>
</blockquote>
<h3 id="2-1-1-类声明"><a href="#2-1-1-类声明" class="headerlink" title="2.1.1. 类声明"></a>2.1.1. 类声明</h3><div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">TaskQueueStdlib</span> <span class="keyword">final</span> : <span class="keyword">public</span> TaskQueueBase &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">TaskQueueStdlib</span>(absl::string_view queue_name, rtc::ThreadPriority priority);</span><br><span class="line">  ~<span class="built_in">TaskQueueStdlib</span>() <span class="keyword">override</span> = <span class="keyword">default</span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">Delete</span><span class="params">()</span> <span class="keyword">override</span></span>;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">PostTask</span><span class="params">(std::unique_ptr&lt;QueuedTask&gt; task)</span> <span class="keyword">override</span></span>;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">PostDelayedTask</span><span class="params">(std::unique_ptr&lt;QueuedTask&gt; task,</span></span></span><br><span class="line"><span class="params"><span class="function">                       <span class="type">uint32_t</span> milliseconds)</span> <span class="keyword">override</span></span>;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  <span class="keyword">using</span> OrderId = <span class="type">uint64_t</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">DelayedEntryTimeout</span> &#123;</span><br><span class="line">    <span class="type">int64_t</span> next_fire_at_ms_&#123;&#125;;</span><br><span class="line">    OrderId order_&#123;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span>&lt;(<span class="type">const</span> DelayedEntryTimeout&amp; o) <span class="type">const</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> std::<span class="built_in">tie</span>(next_fire_at_ms_, order_) &lt;</span><br><span class="line">             std::<span class="built_in">tie</span>(o.next_fire_at_ms_, o.order_);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">NextTask</span> &#123;</span><br><span class="line">    <span class="type">bool</span> final_task_&#123;<span class="literal">false</span>&#125;;</span><br><span class="line">    std::unique_ptr&lt;QueuedTask&gt; run_task_;</span><br><span class="line">    <span class="type">int64_t</span> sleep_time_ms_&#123;&#125;;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="function">NextTask <span class="title">GetNextTask</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">ThreadMain</span><span class="params">(<span class="type">void</span>* context)</span></span>;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">ProcessTasks</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">NotifyWake</span><span class="params">()</span></span>;</span><br><span class="line">  rtc::Event started_;</span><br><span class="line">  rtc::Event stopped_;</span><br><span class="line">  rtc::Event flag_notify_;</span><br><span class="line">  rtc::PlatformThread thread_;</span><br><span class="line">  rtc::CriticalSection pending_lock_;</span><br><span class="line">  <span class="function"><span class="type">bool</span> thread_should_quit_ <span class="title">RTC_GUARDED_BY</span><span class="params">(pending_lock_)</span></span>&#123;<span class="literal">false</span>&#125;;</span><br><span class="line">  <span class="function">OrderId thread_posting_order_ <span class="title">RTC_GUARDED_BY</span><span class="params">(pending_lock_)</span></span>&#123;&#125;;</span><br><span class="line">  std::queue&lt;std::pair&lt;OrderId, std::unique_ptr&lt;QueuedTask&gt;&gt;&gt; <span class="function">pending_queue_</span></span><br><span class="line"><span class="function">      <span class="title">RTC_GUARDED_BY</span><span class="params">(pending_lock_)</span></span>;</span><br><span class="line">  std::map&lt;DelayedEntryTimeout, std::unique_ptr&lt;QueuedTask&gt;&gt; <span class="function">delayed_queue_</span></span><br><span class="line"><span class="function">      <span class="title">RTC_GUARDED_BY</span><span class="params">(pending_lock_)</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div>

<p>可以看出 <code>TaskQueueStdlib</code>的 <code>public</code>成员除构造函数和析构函数之外只有三个函数，<code>private</code>成员都是为了实现 <code>public</code>方法而定义的，所以后续会先分析其私有成员，最后再分析三个 <code>public</code>成员函数的具体实现方式。</p>
<h3 id="2-1-2-私有成员实现"><a href="#2-1-2-私有成员实现" class="headerlink" title="2.1.2. 私有成员实现"></a>2.1.2. 私有成员实现</h3><p>此处使用 <code>using</code>语句，类似于 <code>typedef</code>，类型 <code>OrderId</code>实际上就是 <code>uint64_t</code>。</p>
<h4 id="2-1-2-1-私有数据成员"><a href="#2-1-2-1-私有数据成员" class="headerlink" title="2.1.2.1. 私有数据成员"></a>2.1.2.1. 私有数据成员</h4><div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 表示该线程是否已经开始</span></span><br><span class="line">rtc::Event started_;</span><br><span class="line"><span class="comment">// 表示该线程是否已经结束</span></span><br><span class="line">rtc::Event stopped_;</span><br><span class="line"><span class="comment">// 每当有新的任务等待时，就会发出信号</span></span><br><span class="line">rtc::Event flag_notify_;</span><br><span class="line"><span class="comment">// 表示被分配用于处理任务的活动工作线程</span></span><br><span class="line">rtc::PlatformThread thread_;</span><br><span class="line"><span class="comment">// 对于存在多个线程访问的数据需要上锁</span></span><br><span class="line">rtc::CriticalSection pending_lock_;</span><br><span class="line"><span class="comment">// 表示工作线程是否需要现在关闭</span></span><br><span class="line"><span class="function"><span class="type">bool</span> thread_should_quit_ <span class="title">RTC_GUARDED_BY</span><span class="params">(pending_lock_)</span></span>&#123;<span class="literal">false</span>&#125;;</span><br><span class="line"><span class="comment">// 保存下一个任务的序号，用于将其放入一个挂起的队列中</span></span><br><span class="line"><span class="function">OrderId thread_posting_order_ <span class="title">RTC_GUARDED_BY</span><span class="params">(pending_lock_)</span></span>&#123;&#125;;</span><br><span class="line"><span class="comment">// 需要在工作线程中按照先进先出的队列顺序处理的待办任务列表</span></span><br><span class="line">std::queue&lt;std::pair&lt;OrderId, std::unique_ptr&lt;QueuedTask&gt;&gt;&gt; <span class="function">pending_queue_</span></span><br><span class="line"><span class="function">    <span class="title">RTC_GUARDED_BY</span><span class="params">(pending_lock_)</span></span>;</span><br><span class="line"><span class="comment">// 需要在工作线程中延迟一段时间再处理的待办任务列表，如果两个任务在相同的时间间隔内</span></span><br><span class="line"><span class="comment">// 发生，那么将根据先后顺序进行处理。</span></span><br><span class="line">std::map&lt;DelayedEntryTimeout, std::unique_ptr&lt;QueuedTask&gt;&gt; <span class="function">delayed_queue_</span></span><br><span class="line"><span class="function">    <span class="title">RTC_GUARDED_BY</span><span class="params">(pending_lock_)</span></span>;</span><br></pre></td></tr></table></figure></div>

<h4 id="2-1-2-2-私有成员类-amp-结构"><a href="#2-1-2-2-私有成员类-amp-结构" class="headerlink" title="2.1.2.2. 私有成员类&amp;结构"></a>2.1.2.2. 私有成员类&amp;结构</h4><div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">DelayedEntryTimeout</span> &#123;</span><br><span class="line">  <span class="type">int64_t</span> next_fire_at_ms_&#123;&#125;;</span><br><span class="line">  OederId order_&#123;&#125;;</span><br><span class="line">  </span><br><span class="line">  <span class="type">bool</span> <span class="keyword">operator</span>&lt;(<span class="type">const</span> DelayedEntryTimeout&amp; o) <span class="type">const</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> std::<span class="built_in">tie</span>(next_fire_at_ms_, order_) &lt; </span><br><span class="line">           std::<span class="built_in">tie</span>(o.next_fire_at_ms_, o.order_);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div>

<p><code>DelayedEntryTimeout</code>具有类似于时间戳的功能，<code>next_fire_at_ms_</code>记录了任务执行的绝对时间，<code>OrderId</code>则记录了任务对应的序号，重载了 <code>&lt;</code>操作符用于比较两个<br><code>DelayedEntryTimeout</code>,该属性较小的任务会先被执行。<br><code>DelayedEntryTimeout</code>比较规则：先比较 <code>next_fire_at_ms_</code>，如果不等直接返回对应的 <code>bool</code>值；如果相等，则再次比较 <code>order</code>,返回比较结果对应的 <code>bool</code>值。</p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">NextTask</span> &#123;</span><br><span class="line">  <span class="type">bool</span> final_task_&#123;<span class="literal">false</span>&#125;;</span><br><span class="line">  std::unique_ptr&lt;QueuedTask&gt; run_task_;</span><br><span class="line">  <span class="type">int64_t</span> sleep_time_ms_&#123;&#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div>

<p><code>NextTask</code>用于表示下一个任务，前两个属性很容易理解，第三个属性是为了兼容 <code>DelayedTask</code>而设置的，具体的实现将会在 <code>GetNextTask</code>函数中介绍到。</p>
<h4 id="2-1-2-3-私有成员函数实现"><a href="#2-1-2-3-私有成员函数实现" class="headerlink" title="2.1.2.3. 私有成员函数实现"></a>2.1.2.3. 私有成员函数实现</h4><h5 id="2-1-2-3-1-GetNextTask"><a href="#2-1-2-3-1-GetNextTask" class="headerlink" title="2.1.2.3.1. GetNextTask"></a>2.1.2.3.1. <code>GetNextTask</code></h5><div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">TaskQueu1Stdlib::NextTask <span class="title">TaskQueueStdlib::GetNextTask</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  NextTask result&#123;&#125;;</span><br><span class="line">  <span class="comment">// 获取当前的绝对时间(ms)</span></span><br><span class="line">  <span class="keyword">auto</span> tick = rtc::<span class="built_in">TimeMillis</span>();</span><br><span class="line"></span><br><span class="line">  <span class="function">rtc::CritScope <span class="title">lock</span><span class="params">(&amp;pending_lock_)</span></span>;</span><br><span class="line">  <span class="comment">// 判断是否线程需要退出</span></span><br><span class="line">  <span class="keyword">if</span> (thread_should_quit_) &#123;</span><br><span class="line">    result.final_task_ = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 如果延迟任务队列非空，则首先从其中取出任务 </span></span><br><span class="line">  <span class="keyword">if</span> (delayed_queue_.<span class="built_in">size</span>() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">// 获取延迟任务相关信息</span></span><br><span class="line">    <span class="keyword">auto</span> delayed_entry = delayed_queue_.<span class="built_in">begin</span>();</span><br><span class="line">    <span class="type">const</span> <span class="keyword">auto</span>&amp; delay_info = delayed_entry-&gt;first;</span><br><span class="line">    <span class="keyword">auto</span>&amp; delay_run = delayed_entry-&gt;second;</span><br><span class="line">    <span class="comment">// 判断是否应该执行延迟任务</span></span><br><span class="line">    <span class="keyword">if</span> (tick &gt;= delay_info.next_fire_at_ms_) &#123;</span><br><span class="line">      <span class="comment">// 如果即时任务队列非空，通过比较决定取出哪种任务</span></span><br><span class="line">      <span class="keyword">if</span> (pending_queue_.<span class="built_in">size</span>() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">auto</span>&amp; entry = pending_queue_.<span class="built_in">front</span>();</span><br><span class="line">        <span class="keyword">auto</span>&amp; entry_order = entry.first;</span><br><span class="line">        <span class="keyword">auto</span>&amp; entry_run = entry.second;</span><br><span class="line">        <span class="comment">// 如果即时任务序号较小，则直接返回该即时任务 </span></span><br><span class="line">        <span class="keyword">if</span> (entry_order &lt; delay_info.order_) &#123;  </span><br><span class="line">          result.run_task_ = std::<span class="built_in">move</span>(entry_run);              <span class="comment">//&lt;--1</span></span><br><span class="line">          pending_queue_.<span class="built_in">pop</span>();</span><br><span class="line">          <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 如果即时任务队列为空，或者1处即时任务序号较大，则取出最靠前的延迟任务</span></span><br><span class="line">      result.run_task_ = std::<span class="built_in">move</span>(delay_run);                  <span class="comment">//&lt;--2</span></span><br><span class="line">      delayed_queue_.<span class="built_in">erase</span>(delayed_entry);</span><br><span class="line">      <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ！！如果运行到这里，此时result.task_run_为nullptr，表明没有任务需要处理</span></span><br><span class="line">    <span class="comment">// 更新sleep_time_ms_</span></span><br><span class="line">    result.sleep_time_ms_ = delay_info.next_fire_at_ms_ - tick; <span class="comment">//&lt;--3</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 延迟任务队列为空，即时任务队列非空</span></span><br><span class="line">  <span class="keyword">if</span> (pending_queue_.<span class="built_in">size</span>() &gt; <span class="number">0</span>) &#123;   </span><br><span class="line">    <span class="keyword">auto</span>&amp; entry = pending_queue_.<span class="built_in">front</span>();                       <span class="comment">//&lt;--4</span></span><br><span class="line">    result.run_task_ = std::<span class="built_in">move</span>(entry.second);</span><br><span class="line">    pending_queue_.<span class="built_in">pop</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>其中涉及到 <code>map</code>和 <code>queue</code>两个容器的相关函数，可以自行查阅。<br>由于 <code>NextTask</code>结构体内部的 <code>run_task_</code>为 <code>unique_ptr</code>，所以不能直接赋值而是使用 <code>std::move</code>转移所有权。</p>
<p><code>GetNextTask</code>函数体较长，逻辑略显复杂，而且非常重要，一定要理清楚如何从任务队列中取出任务。<br>代码块里做了四处标记，便于理解整个流程（此处分析认为 <code>thread_should_quit_</code>为 <code>true</code>）：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">if 延迟任务队列非空</span><br><span class="line">  if 需要执行下一个延迟任务</span><br><span class="line">    if 即时任务队列非空</span><br><span class="line">      if 即时任务序号较小</span><br><span class="line">        返回即时任务(1)</span><br><span class="line">      else </span><br><span class="line">        返回延迟任务(2)</span><br><span class="line">    else</span><br><span class="line">      返回延迟任务(2)</span><br><span class="line">  else</span><br><span class="line">    更新result.sleep_time_ms_(3)</span><br><span class="line">if 即时任务队列非空</span><br><span class="line">  result.run_task_设置为即时任务(4)</span><br><span class="line">返回result</span><br></pre></td></tr></table></figure></div>

<p>这一部分可以概括为：</p>
<ul>
<li><code>result.run_task_</code>为空，<code>result.sleep_time_ms_</code>为0时：两个任务队列均为空</li>
<li><code>result.run_task_</code>为空，<code>result.sleep_time_ms_</code>不为0时：即时任务队列为空，延迟任务队列非空，但是没有可执行的延迟任务</li>
<li><code>result.run_task_</code>不为空，<code>result.sleep_time_ms_</code>为0时：即时任务队列非空，延迟任务队列为空</li>
<li><code>result.run_task_</code>不为空，<code>result.sleep_time_ms_</code>不为0时：即时任务队列非空，延迟任务队列非空，但是没有可执行的延迟任务</li>
</ul>
<h5 id="2-1-2-3-2-ThreadMain"><a href="#2-1-2-3-2-ThreadMain" class="headerlink" title="2.1.2.3.2 ThreadMain"></a>2.1.2.3.2 <code>ThreadMain</code></h5><div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// static</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">TaskQueueStdlib::ThreadMain</span><span class="params">(<span class="type">void</span>* context)</span> </span>&#123;</span><br><span class="line">  TaskQueueStdlib* me = <span class="built_in">static_cast</span>&lt;TaskQueueStdlib*&gt;(context);</span><br><span class="line">  <span class="function">CurrentTaskQueueSetter <span class="title">set_current</span><span class="params">(me)</span></span>;</span><br><span class="line">  me-&gt;<span class="built_in">ProcessTasks</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p><code>ThreadMain</code>是任务处理线程真正的入口函数，其首先将传入的参数强制转换成 <code>TaskQueueStdlib*</code>,然后将这个任务队列注册到当前的线程中，随后开始处理任务。<br>注意此函数是一个 <code>static</code>函数。</p>
<h5 id="2-1-2-3-3-ProcessTasks"><a href="#2-1-2-3-3-ProcessTasks" class="headerlink" title="2.1.2.3.3. ProcessTasks"></a>2.1.2.3.3. <code>ProcessTasks</code></h5><div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">TaskQueueStdlib::ProcessTasks</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  started_.<span class="built_in">Set</span>();</span><br><span class="line">  <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="keyword">auto</span> task = <span class="built_in">GetNextTask</span>();</span><br><span class="line">    <span class="keyword">if</span> (task.final_task_)</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">if</span> (task.run_task_) &#123;</span><br><span class="line">      <span class="comment">// release()会解除智能指针对这个QueuedTask的占用，</span></span><br><span class="line">      <span class="comment">// 并将该智能指针置空</span></span><br><span class="line">      QueuedTask* release_ptr = task.run_task_.<span class="built_in">release</span>();</span><br><span class="line">      <span class="keyword">if</span> (release_ptr-&gt;<span class="built_in">Run</span>())</span><br><span class="line">        <span class="keyword">delete</span> release_ptr;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 取出下一个任务</span></span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// task.sleep_time_ms_为0时表示</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="number">0</span> == task.sleep_time_ms_)</span><br><span class="line">      flag_notify_.<span class="built_in">Wait</span>(rtc::Event::kForever);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      flag_notify_.<span class="built_in">Wait</span>(task.sleep_time_ms_);</span><br><span class="line">  &#125;</span><br><span class="line">  stopped_.<span class="built_in">Set</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p><code>ProcessTasks</code>函数与 <code>GetNextTask</code>函数协同工作。由 <code>GetNextTask</code>函数部分的分析可知只要 <code>task.run_task_</code>为空，就说明即时任务队列为空且暂时没有需要执行的任务，但此时又面临着两种情况：</p>
<ul>
<li>如果延迟任务队列为空，那么直接睡眠直到被唤起</li>
<li>如果延迟任务队列非空，那么将会睡眠指定时间</li>
</ul>
<h5 id="2-1-2-3-4-NotifyWake"><a href="#2-1-2-3-4-NotifyWake" class="headerlink" title="2.1.2.3.4. NotifyWake"></a>2.1.2.3.4. <code>NotifyWake</code></h5><div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">TaskQueueStdlib::NotifyWake</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  flag_notify_.<span class="built_in">Set</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>任务队列中存放着待执行的任务：</p>
<ul>
<li>对于即时任务，线程会忙于执行该任务而不会等待 <code>flag_notify_</code>事件。</li>
<li>如果没有即时任务，但有一个延迟任务正在等待，那么线程将会等待 <code>flag_notify_</code>事件，也就是 <code>ProcessTasks</code>中所提及到的 <code>flag_notify_.Wait(task.sleep_time_ms_);</code></li>
<li>如果即时任务队列和延迟任务队列都为空，那么线程将无限期等待 <code>flag_notify_</code>事件，直到有一个信号显示有新的任务被添加（或者告诉线程需要终止）。</li>
</ul>
<p>任何情况下，当一个新的上述请求被添加后，会发出 <code>flag_notify_</code>信号。如果此时线程正在等待，则会被立即唤醒并且重新评估下一步需要做什么。如果线程并没有在等待，那么线程将保持信号，在下一次试图等待 <code>flag_notify_</code>事件发生时被唤醒。</p>
<p>在发出 <code>flag_notify_</code>信号来唤醒可能正在睡眠的线程之前，需要确保有任务或相关请求添加到队列中，从而避免竞争情况：线程被通知唤醒但是发现没有任务需要执行，所以会再次等待信号，然而这样的信号将有可能不会再次出现。</p>
<h3 id="2-1-3-公有成员实现"><a href="#2-1-3-公有成员实现" class="headerlink" title="2.1.3. 公有成员实现"></a>2.1.3. 公有成员实现</h3><h4 id="2-1-3-1-公有成员函数实现"><a href="#2-1-3-1-公有成员函数实现" class="headerlink" title="2.1.3.1. 公有成员函数实现"></a>2.1.3.1. 公有成员函数实现</h4><h5 id="2-1-3-1-1-TaskQueueStdlib"><a href="#2-1-3-1-1-TaskQueueStdlib" class="headerlink" title="2.1.3.1.1. TaskQueueStdlib"></a>2.1.3.1.1. <code>TaskQueueStdlib</code></h5><div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line">TaskQueueStdlib::<span class="built_in">TaskQueueStdlib</span>(absl::string_view queue_name,</span><br><span class="line">                                 rtc::ThreadPriority priority)</span><br><span class="line">    : <span class="built_in">started_</span>(<span class="comment">/*manual_reset=*/</span><span class="literal">false</span>, <span class="comment">/*initially_signaled=*/</span><span class="literal">false</span>),</span><br><span class="line">      <span class="built_in">stopped_</span>(<span class="comment">/*manual_reset=*/</span><span class="literal">false</span>, <span class="comment">/*initially_signaled=*/</span><span class="literal">false</span>),</span><br><span class="line">      <span class="built_in">flag_notify_</span>(<span class="comment">/*manual_reset=*/</span><span class="literal">false</span>, <span class="comment">/*initially_signaled=*/</span><span class="literal">false</span>),</span><br><span class="line">      <span class="built_in">thread_</span>(&amp;TaskQueueStdlib::ThreadMain, <span class="keyword">this</span>, queue_name, priority) &#123;</span><br><span class="line">  thread_.<span class="built_in">Start</span>();</span><br><span class="line">  started_.<span class="built_in">Wait</span>(rtc::Event::kForever);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>创建一个任务处理线程，随后开始执行入口函数并挂起当前线程。<br>当任务处理线程准备就绪之后，会唤醒当前线程。<br>当前线程负责创建一个任务处理线程并且向其投递任务，任务处理线程负责处理任务队列内的任务。</p>
<h5 id="2-1-3-1-2-Delete"><a href="#2-1-3-1-2-Delete" class="headerlink" title="2.1.3.1.2.Delete"></a>2.1.3.1.2.<code>Delete</code></h5><div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">TaskQueueStdlib::Delete</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">RTC_DCHECK</span>(!<span class="built_in">IsCurrent</span>());</span><br><span class="line"></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="function">rtc::CritScope <span class="title">lock</span><span class="params">(&amp;pending_lock_)</span></span>;</span><br><span class="line">    thread_should_quit_ = <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">NotifyWake</span>();</span><br><span class="line"></span><br><span class="line">  stopped_.<span class="built_in">Wait</span>(rtc::Event::kForever);</span><br><span class="line">  thread_.<span class="built_in">Stop</span>();</span><br><span class="line">  <span class="keyword">delete</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>此函数用于销毁任务队列对象：</p>
<ul>
<li>首先判断当前线程是不是任务处理线程，因为销毁操作不可以在任务处理线程中进行</li>
<li>随后标记任务处理线程需要退出并唤醒线程执行相关任务</li>
<li>然后当前线程等待任务处理线程退出后唤醒主线程</li>
<li>主线程回收任务处理线程，最后释放任务队列对象</li>
</ul>
<h5 id="2-1-3-1-3-PostTask"><a href="#2-1-3-1-3-PostTask" class="headerlink" title="2.1.3.1.3. PostTask"></a>2.1.3.1.3. <code>PostTask</code></h5><div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">TaskQueueStdlib::PostTask</span><span class="params">(std::unique_ptr&lt;QueuedTask&gt; task)</span> </span>&#123;</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="function">rtc::CritScope <span class="title">lock</span><span class="params">(&amp;pending_lock_)</span></span>;</span><br><span class="line">    <span class="comment">// 序号自增赋值</span></span><br><span class="line">    OrderId order = thread_posting_order_++;</span><br><span class="line">    <span class="comment">// 加入到即时任务队列中</span></span><br><span class="line">    pending_queue_.<span class="built_in">push</span>(std::pair&lt;OrderId, std::unique_ptr&lt;QueuedTask&gt;&gt;(</span><br><span class="line">        order, std::<span class="built_in">move</span>(task)));</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 唤醒任务处理线程处理任务</span></span><br><span class="line">  <span class="built_in">NotifyWake</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h5 id="2-1-3-1-4-PostDelayedTask"><a href="#2-1-3-1-4-PostDelayedTask" class="headerlink" title="2.1.3.1.4. PostDelayedTask"></a>2.1.3.1.4. <code>PostDelayedTask</code></h5><div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">TaskQueueStdlib::PostDelayedTask</span><span class="params">(std::unique_ptr&lt;QueuedTask&gt; task,</span></span></span><br><span class="line"><span class="params"><span class="function">                                      <span class="type">uint32_t</span> milliseconds)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 计算延迟任务的执行时间（绝对时间）</span></span><br><span class="line">  <span class="keyword">auto</span> fire_at = rtc::<span class="built_in">TimeMillis</span>() + milliseconds;</span><br><span class="line"></span><br><span class="line">  DelayedEntryTimeout delay;</span><br><span class="line">  <span class="comment">// 设置延迟任务的执行时间</span></span><br><span class="line">  delay.next_fire_at_ms_ = fire_at;</span><br><span class="line"></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="function">rtc::CritScope <span class="title">lock</span><span class="params">(&amp;pending_lock_)</span></span>;</span><br><span class="line">    <span class="comment">// 序号自增赋值</span></span><br><span class="line">    delay.order_ = ++thread_posting_order_;</span><br><span class="line">    delayed_queue_[delay] = std::<span class="built_in">move</span>(task);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 唤醒任务处理线程处理任务</span></span><br><span class="line">  <span class="built_in">NotifyWake</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h1 id="3-总结"><a href="#3-总结" class="headerlink" title="3. 总结"></a>3. 总结</h1><p><code>TaskQueueStdlib</code>涉及到任务队列的核心实现方式，尤其是 <code>GetNextTask</code>和 <code>ProcessTasks</code>两个函数，需要理清相关的逻辑，从而了解整个模块的流程。</p>
]]></content>
      <tags>
        <tag>WebRTC</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/2022/12/05/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a class="link"   href="https://hexo.io/" >Hexo<i class="fas fa-external-link-alt"></i></a>! This is your very first post. Check <a class="link"   href="https://hexo.io/docs/" >documentation<i class="fas fa-external-link-alt"></i></a> for more info. If you get any problems when using Hexo, you can find the answer in <a class="link"   href="https://hexo.io/docs/troubleshooting.html" >troubleshooting<i class="fas fa-external-link-alt"></i></a> or you can ask me on <a class="link"   href="https://github.com/hexojs/hexo/issues" >GitHub<i class="fas fa-external-link-alt"></i></a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure></div>

<p>More info: <a class="link"   href="https://hexo.io/docs/writing.html" >Writing<i class="fas fa-external-link-alt"></i></a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure></div>

<p>More info: <a class="link"   href="https://hexo.io/docs/server.html" >Server<i class="fas fa-external-link-alt"></i></a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure></div>

<p>More info: <a class="link"   href="https://hexo.io/docs/generating.html" >Generating<i class="fas fa-external-link-alt"></i></a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure></div>

<p>More info: <a class="link"   href="https://hexo.io/docs/one-command-deployment.html" >Deployment<i class="fas fa-external-link-alt"></i></a></p>
]]></content>
      <tags>
        <tag>init</tag>
      </tags>
  </entry>
</search>
